window.onerror = function () {
    // window.location.href = 'https://eichi2514.github.io/ascentlime/restricted/restricted';
};

const weapon = [
    '../image/weapon/weapon0.png',

    '../image/weapon/weapon1.png',
    '../image/weapon/weapon2.png',
    '../image/weapon/weapon3.png',
    '../image/weapon/weapon4.png',
    '../image/weapon/weapon5.png',
    '../image/weapon/weapon6.png',
    '../image/weapon/weapon7.png',
    '../image/weapon/weapon8.png',
    '../image/weapon/weapon9.png',
    '../image/weapon/weapon10.png',

    '../image/weapon/weapon11.png',
    '../image/weapon/weapon12.png',
    '../image/weapon/weapon13.png',
    '../image/weapon/weapon14.png',
    '../image/weapon/weapon15.png',
    '../image/weapon/weapon16.png',
    '../image/weapon/weapon17.png',
    '../image/weapon/weapon18.png',
    '../image/weapon/weapon19.png',
    '../image/weapon/weapon20.png',

    '../image/weapon/weapon21.png',
    '../image/weapon/weapon22.png',
    '../image/weapon/weapon23.png',
    '../image/weapon/weapon24.png',
    '../image/weapon/weapon25.png',
    '../image/weapon/weapon26.png',
    '../image/weapon/weapon27.png',
    '../image/weapon/weapon28.png',
    '../image/weapon/weapon29.png',
    '../image/weapon/weapon30.png',

    '../image/weapon/weapon31.png',
    '../image/weapon/weapon32.png',
    '../image/weapon/weapon33.png',
    '../image/weapon/weapon34.png',
    '../image/weapon/weapon35.png',
    '../image/weapon/weapon36.png',
    '../image/weapon/weapon37.png',
    '../image/weapon/weapon38.png',
    '../image/weapon/weapon39.png',
    '../image/weapon/weapon40.png',

    '../image/weapon/weapon41.png',
    '../image/weapon/weapon42.png',
    '../image/weapon/weapon43.png',
    '../image/weapon/weapon44.png',
    '../image/weapon/weapon45.png',
    '../image/weapon/weapon46.png',
    '../image/weapon/weapon47.png',
    '../image/weapon/weapon48.png',
    '../image/weapon/weapon49.png',
    '../image/weapon/weapon50.png',

    '../image/weapon/weapon51.png',
    '../image/weapon/weapon52.png',
    '../image/weapon/weapon53.png',
    '../image/weapon/weapon54.png',
    '../image/weapon/weapon55.png',
    '../image/weapon/weapon56.png',
    '../image/weapon/weapon57.png',
    '../image/weapon/weapon58.png',
    '../image/weapon/weapon59.png',
    '../image/weapon/weapon60.png',

    '../image/weapon/weapon61.png',
    '../image/weapon/weapon62.png',
    '../image/weapon/weapon63.png',
    '../image/weapon/weapon64.png',
    '../image/weapon/weapon65.png',
    '../image/weapon/weapon66.png',
    '../image/weapon/weapon67.png',
    '../image/weapon/weapon68.png',
    '../image/weapon/weapon69.png',
    '../image/weapon/weapon70.png'
];

const weaponNames = [
    '???',

    '톡신 오브',
    '디케이 큐브',
    '베놈 랜스',
    '포이즌 스타',
    '플라그 애로우',
    '코러시브 빔',
    '테트라 팽',
    '블라이트 봄버맨',
    '퍼시드 스매셔',
    '제노시스 블레이드',

    '어비스 오브',
    '크립틱 큐브',
    '나이트 랜스',
    '쉐이드 스타',
    '팬텀 애로우',
    '루나 빔',
    '섀도우 팽',
    '나이트폴 봄버맨',
    '스펙터 스매셔',
    '루나틱 블레이드',

    '스톰 오브',
    '타이달 큐브',
    '블리자드 랜스',
    '스카이 스타',
    '제피르 애로우',
    '볼텍스 빔',
    '게일 팽',
    '프로스트 봄버맨',
    '스카이 스매셔',
    '글레이셔 블레이드',

    '포레스트 오브',
    '베르던트 큐브',
    '가이아 랜스',
    '실피드 스타',
    '바인 애로우',
    '테라 빔',
    '와일드 팽',
    '가이아 봄버맨',
    '네이처 스매셔',
    '스피릿 블레이드',

    '라이트닝 오브',
    '볼태틱 큐브',
    '스파크 랜스',
    '라디언트 스타',
    '플래시 애로우',
    '라디언트 빔',
    '썬더 팽',
    '템페스트 봄버맨',
    '디바인 스매셔',
    '플라즈마 블레이드',

    '서지 오브',
    '라디언트 큐브',
    '블레이즈 랜스',
    '썬셋 스타',
    '플레어 애로우',
    '솔라 빔',
    '폭풍 팽',
    '썬더 봄버맨',
    '파워 스매셔',
    '에너제틱 블레이드',

    '파이어 오브',
    '인페르노 큐브',
    '헬파이어 랜스',
    '플레임 스타',
    '피닉스 애로우',
    '블러드 빔',
    '크림슨 팽',
    '블레이즈 봄버맨',
    '파이로 스매셔',
    '인페르노 블레이드'
];

const mobs = [
    '../image/mob/mob0.png',

    '../image/mob/mob1.png',
    '../image/mob/mob2.png',
    '../image/mob/mob3.png',
    '../image/mob/mob4.png',
    '../image/mob/mob5.png',
    '../image/mob/mob6.png',
    '../image/mob/mob7.png',
    '../image/mob/mob8.png',
    '../image/mob/mob9.png',
    '../image/mob/mob10.png',

    '../image/mob/mob11.png',
    '../image/mob/mob12.png',
    '../image/mob/mob13.png',
    '../image/mob/mob14.png',
    '../image/mob/mob15.png',
    '../image/mob/mob16.png',
    '../image/mob/mob17.png',
    '../image/mob/mob18.png',
    '../image/mob/mob19.png',
    '../image/mob/mob20.png',

    '../image/mob/mob21.png',
    '../image/mob/mob22.png',
    '../image/mob/mob23.png',
    '../image/mob/mob24.png',
    '../image/mob/mob25.png',
    '../image/mob/mob26.png',
    '../image/mob/mob27.png',
    '../image/mob/mob28.png',
    '../image/mob/mob29.png',
    '../image/mob/mob30.png',

    '../image/mob/mob31.png',
    '../image/mob/mob32.png',
    '../image/mob/mob33.png',
    '../image/mob/mob34.png',
    '../image/mob/mob35.png',
    '../image/mob/mob36.png',
    '../image/mob/mob37.png',
    '../image/mob/mob38.png',
    '../image/mob/mob39.png',
    '../image/mob/mob40.png',

    '../image/mob/mob41.png',
    '../image/mob/mob42.png',
    '../image/mob/mob43.png',
    '../image/mob/mob44.png',
    '../image/mob/mob45.png',
    '../image/mob/mob46.png',
    '../image/mob/mob47.png',
    '../image/mob/mob48.png',
    '../image/mob/mob49.png',
    '../image/mob/mob50.png',

    '../image/mob/mob51.png',
    '../image/mob/mob52.png',
    '../image/mob/mob53.png',
    '../image/mob/mobLast.png'
];

const mobNames = [
    '???',

    '블루 슬라임',
    '그린 슬라임',
    '레드 슬라임',
    '베놈 슬라임',
    '다크 슬라임',
    '체리 슬라임',
    '아이언 슬라임',
    '골드 슬라임',
    '버닝 슬라임',
    '투명 슬라임',

    '아쿠아 어센트라임',
    '에메랄드 어센트라임',
    '파이어 어센트라임',
    '포이즌 어센트라임',
    '섀도우 어센트라임',
    '블라썸 어센트라임',
    '스틸 어센트라임',
    '에테르 어센트라임',
    '라즈비어 어센트라임',
    '루미너스 어센트라임',

    '프리징 큐브라임',
    '플로라 큐브라임',
    '블러드 큐브라임',
    '플레그마 큐브라임',
    '테르미누스 큐브라임',
    '피탈 큐브라임',
    '머슬 큐브라임',
    '제니스 큐브라임',
    '이그니스 큐브라임',
    '미스트 큐브라임',

    '하이 라디임',
    '바이오 라디임',
    '크림슨 라디임',
    '퍼시드 라디임',
    '문더스트 라디임',
    '피오르 라디임',
    '아머드 라디임',
    '로열 라디임',
    '블래즈 라디임',
    '글로우 라디임',

    '템페스트 드라임',
    '가이아 드라임',
    '인페르노 드라임',
    '제노시스 드라임',
    '오블리비언 드라임',
    '그로스 드라임',
    '어센디드 드라임',
    '엠페르트 드라임',
    '인페르노 드라임',
    '일루전 드라임',

    '블루 슬라임킹',
    '그린 슬라임킹',
    '레드 슬라임킹',
    '초보 등반자 (여)'
];

const nickname = localStorage.getItem('nickname') || sessionStorage.getItem('nickname');

if (!nickname) {
    alert('로그인이 필요한 서비스 입니다');
    history.back();
}

let charac = null;
let front_hp = null;
let front_power = null;
let front_speed = null;
let front_money = null;
let front_weaponId = null;
let front_weaponUpgrade = null;

const $hp_count = $('.hp_count');
const $power_count = $('.power_count');
const $speed_count = $('.speed_count');
const $money_count = $('.money_count');
const $weapon_img = $('.weapon_img');
let upgradeNum = null;
let seconds = null;

let $item = null;
let $item_text = null;
const $random_item = $(".random_item");
const $random_item_text = $(".random_item_text");
const $alert = $('.alert')
const $alert_title = $('.alert_title');
let weaponMax = null;
let $randomWeapon = null;
let randomItem = null;

let previousFloor = null;
let previousRoom = null;

let previousTrackNumber = null;
let currentTrackNumber = null;

let $mob_index = null;

let characFloor = null;
let characRoom = null;
let characWeaponId = null;

let damage = null;

// 캐릭터 위치 변수
let LR = 10;
let UD = 44;

// 몬스터 좌표 셋팅
let UD2 = getRandom(10, 70);
if (UD2 % 2 !== 0) UD2++;
let LR2 = getRandom(30, 70);
if (LR2 % 2 !== 0) LR2++;

let UD3 = getRandom(10, 70);
if (UD3 % 2 !== 0) UD3++;
let LR3 = getRandom(30, 70);
if (LR3 % 2 !== 0) LR3++;

let UD4 = getRandom(10, 70);
if (UD4 % 2 !== 0) UD4++;
let LR4 = getRandom(30, 70);
if (LR4 % 2 !== 0) LR4++;

let UD5 = getRandom(10, 70);
if (UD5 % 2 !== 0) UD5++;
let LR5 = getRandom(30, 70);
if (LR5 % 2 !== 0) LR5++;

let UD6 = getRandom(10, 40);
if (UD6 % 2 !== 0) UD6++;
let LR6 = getRandom(30, 40);
if (LR6 % 2 !== 0) LR6++;

const $mob2 = $(".mob2");
const $mob3 = $(".mob3");
const $mob4 = $(".mob4");
const $mob5 = $(".mob5");
const $mob6 = $(".mob6");

let mobDamage = 0;

if (!localStorage.getItem('cutscene1')) {
    localStorage.setItem('cutscene1', true);
    window.location.href = '../cutscene/tutorial.html';
}

function mob__dictionary2() {
    for (let i = 1; i <= 80; i++) {
        const mobName = i < mobs.length ? `${i}층 몬스터` : `출시예정`;

        $('.mob__dictionary_inner2').append(`
            <div class="mob__dictionary_card2">
                <img src="" alt="../image/map/mystery.png" class="mob__dictionary_title2 mobImage${i}" onerror="this.src=this.alt;">
                <div class="mob__dictionary_body2 mobName${i}">${mobName}</div>
            </div>
        `)
    }
}

mob__dictionary2();

function mob__dictionary() {
    for (let i = 1; i < mobs.length; i++) {
        $('.mob__dictionary_inner').append(`
            <div class="mob__dictionary_card inline-block">
                <img src="../image/map/mystery.png" alt="mobImage" class="mob__dictionary_title mobImage${i}">
                <div class="mob__dictionary_body mobName${i}">${i}층 몬스터</div>
            </div>
        `)
    }
}

mob__dictionary();

function weapon__dictionary() {
    for (let i = 1; i < weapon.length; i++) {
        $('.weapon__dictionary_inner').append(`
            <div class="weapon__dictionary_card inline-block">
                <img src="../image/map/mystery.png" alt="weaponImage" class="weapon__dictionary_title weaponImage${i}">
                <div class="weapon__dictionary_body weaponName${i}">${i}번 무기</div>
            </div>
        `)

        $('.weapon__dictionary_inner2').append(`
            <div class="weapon__dictionary_card2 inline-block">
                <img src="../image/map/mystery.png" alt="weaponImage" class="weapon__dictionary_title2 weaponImage${i}">
                <div class="weapon__dictionary_body2 weaponName${i}">${i}번 무기</div>
            </div>
        `)
    }
}

weapon__dictionary();

async function updateCharacterData(nickname) {
    if (nickname) {
        charac = await characCheckMap(nickname);
        front_hp = charac.hp || 0;
        front_power = charac.power || 0;
        front_speed = charac.speed || 0;
        front_money = charac.money || 0;
        front_weaponId = charac.weaponId;
        front_weaponUpgrade = 0;
        seconds = charac.clearTime;

        characFloor = charac.floor;
        characRoom = charac.room;
        characWeaponId = charac.weaponId;

        if (charac.weaponUpgrade != null) {
            front_weaponUpgrade = charac.weaponUpgrade;
        }

        upgradeNum = front_weaponUpgrade < 100 ? front_weaponUpgrade : 90;

        if (charac.floor === 1 && charac.room === 0) {
            $('.location').text('튜토리얼');
        } else if (charac.room !== 0) {
            $('.location').text(charac.floor + '층 ' + charac.room + '번방');
        } else {
            $('.location').text((charac.floor - 1) + '층 보스방');
        }

        if (10 < characFloor && characFloor <= 20) {
            for (let mobNum = 2; mobNum <= 6; mobNum++) {
                $(`.mob${mobNum}`).append(`
                    <img class="meleeAttack meleeAttack${mobNum} absolute" src="https://github.com/user-attachments/assets/77b4280b-1541-43d0-9659-c6ef81c1cea0" alt="몬스터 무기${mobNum}"/>
                `);
            }
        }

        if (50 < characFloor) {
            const spawnCount = (characRoom === 1 ? 10 : characRoom === 2 ? 13 : characRoom === 3 ? 15 : characRoom === 4 ? 17 : 10) + (characFloor - 50);

            const UDs = {};
            const LRs = {};

            for (let i = 7; i < spawnCount; i++) {
                if (characRoom != 0) {
                    const mobHP_bar = `mob${getRandom(2, characRoom + 1)}HP_bar`;
                    $('.mapBody').prepend(`
                        <div class="front_mob mob${i} fake_mob">
                            <div class="${mobHP_bar} absolute bg-red-500"></div>
                            <img class="front_mob_img mob_img"/>
                        </div>
                    `);
                } else {
                    $('.mapBody').prepend(`
                        <div class="front_bossMob mob${i} fake_mob">
                            <img class="front_bossMob_img mob_img"/>
                        </div>
                    `);
                }


                UDs[i] = getRandom(10, 70);
                LRs[i] = getRandom(30, 70);

                $(`.mob${i}`).css("top", UDs[i] + "vh");
                $(`.mob${i}`).css("left", LRs[i] + "vh");

                (function(index) {
                    const intervalId = setInterval(() => {
                        if (mob2_hp <= 0 && mob3_hp <= 0 && mob4_hp <= 0 && mob5_hp <= 0 && mob6_hp <= 0) {
                            clearInterval(intervalId);
                            $('.fake_mob').fadeOut(2000, function () {
                                $(this).addClass('hidden');
                            });
                        }

                        const random = getRandom(1, 4);
                        if (random === 1 && UDs[index] > 11) {
                            UDs[index] -= 2;
                        } else if (random === 2 && UDs[index] < 69) {
                            UDs[index] += 2;
                        } else if (random === 3 && LRs[index] > 11) {
                            LRs[index] -= 2;
                        } else if (random === 4 && LRs[index] < 69) {
                            LRs[index] += 2;
                        }

                        $(`.mob${index}`).css("top", UDs[index] + "vh");
                        $(`.mob${index}`).css("left", LRs[index] + "vh");
                    }, getRandom(400, 600));
                })(i);
            }
        }

        $hp_count.text(front_hp);
        $power_count.text(front_power);
        $speed_count.text(50 - front_speed);
        $money_count.text(front_money);

        $item = charac.weaponId < 70 ? $(".item1") : $(".item2");
        $item_text = charac.weaponId < 70 ? $(".item_text1") : $(".item_text2");

        weaponMax = (charac.floor - 1) * 10;
        if (weaponMax > 70) weaponMax = 70;
        $randomWeapon = getRandom(1, weaponMax);

        randomItem = getRandom(1, 3);

        if (randomItem === 3) $('.random_item_effect').removeClass('hidden');

        if (charac.room === 1) {
            if (mobFind < charac.floor) {
                // localStorage.setItem(nickname + 'MobFind', charac.floor);
                await mobFindUpdate(nickname, charac.floor);
                mobFind = charac.floor;
            }
        }

        previousFloor = charac.floor;
        previousRoom = charac.room;

        previousTrackNumber = calculateBgTrackNumber(previousFloor - (previousRoom === 0 ? 1 : 0), previousRoom === 0 ? 4 : previousRoom - 1);
        currentTrackNumber = calculateBgTrackNumber(charac.floor, charac.room);

        $mob_index = charac.floor;

        // $('.attackSize').attr('src', weapon[front_weaponId]);
        if (characWeaponId < 70) $item.attr('src', weapon[$randomWeapon]);

        const $toggleButton = $('#toggleAutoplayButton');

        // 오디오 파일 로드 및 준비
        $audioPlayer[0].pause();
        $audioPlayer.attr('src', `../audio/bg${currentTrackNumber}.mp3`);
        $audioPlayer[0].load();

        // 로컬 저장된 데이터가 있으면 그 상태로 복원
        const savedData = JSON.parse(localStorage.getItem(storageKey));
        if (savedData) {
            $audioPlayer[0].currentTime = savedData.currentTime;
            if (savedData.isPlaying) {
                $audioPlayer[0].play();
                $toggleButton.removeClass('play').addClass('pause');
            } else {
                $audioPlayer[0].pause();
                $toggleButton.removeClass('pause').addClass('play');
            }
        }

        // 첫 번째 클릭 시 오디오 재생
        $toggleButton.on('click', function () {
            if ($audioPlayer[0].paused) {
                $audioPlayer[0].play().then(() => {
                    localStorage.setItem(storageKey, JSON.stringify({
                        currentTime: $audioPlayer[0].currentTime,
                        isPlaying: true
                    }));
                    $(this).removeClass('play').addClass('pause');
                }).catch((error) => {
                    console.error("오디오 재생 실패:", error);
                });
            } else {
                $audioPlayer[0].pause();
                localStorage.setItem(storageKey, JSON.stringify({
                    currentTime: $audioPlayer[0].currentTime,
                    isPlaying: false
                }));
                $(this).removeClass('pause').addClass('play');
            }
        });

        $('.weapon').append(`
        <div class="weapon_img_text">            
            <div>${weaponNames[front_weaponId]}</div>
            데미지 ${(Math.ceil(front_weaponId / 10) * 10) + (front_weaponUpgrade)} <br>
            사거리 ${front_weaponId % 10 === 0 ? 12 : (front_weaponId % 10) + 2}
        </div>
        `);

        weapon_img();

        if ($mob_index > 53) {
            $mob_index = getRandom(1, 53);
        }

        $(".rate").text(100 - upgradeNum);

        if (characRoom === 0) $('.mob_img').attr('src', mobs[$mob_index - 1]);
        else $('.mob_img').attr('src', mobs[$mob_index]);

        damage = ((Math.floor(front_weaponId / 10)) * 10) + front_power + front_weaponUpgrade;
        if ((front_weaponId % 10) !== 0) {
            damage += 10;
        }

        mobDamage = characFloor;
        if (characRoom === 0) {
            mobDamage--;
        }

        // 알림창을 표시
        if (characFloor === 1 && characRoom === 0) {
            let $tutorialContainer = $("#tutorialContainer");
            // guide1 추가
            $tutorialContainer.append('<div class="guide1 bg-black text-gray-400 text-center absolute">A W D S : 공격</div>');
            // guide2 추가
            $tutorialContainer.append('<div class="guide2 bg-black text-gray-400 text-center absolute">← ↑ → ↓ : 이동</div>');
        }

        $mob2.css("top", UD2 + "vh");
        $mob3.css("top", UD3 + "vh");
        $mob4.css("top", UD4 + "vh");
        $mob5.css("top", UD5 + "vh");
        $mob6.css("top", UD6 + "vh");

        $mob2.css("left", LR2 + "vh");
        $mob3.css("left", LR3 + "vh");
        $mob4.css("left", LR4 + "vh");
        $mob5.css("left", LR5 + "vh");
        $mob6.css("left", LR6 + "vh");

        let moveInterval; // 캐릭터 이동을 위한 interval
        let moveActionCheck = null; // 현재 움직이고 있는 방향 추적

        function startMoving(moveAction) {
            // 이미 해당 방향으로 움직이고 있으면 중복 방지
            if (moveActionCheck === moveAction) return;

            // 새로운 방향으로 이동 시작
            stopMoving(); // 이전 움직임을 중지하고 새로운 움직임 시작
            moveActionCheck = moveAction;

            moveInterval = setInterval(function () {
                moveCharacter(moveAction, 1)
            }, front_speed);
        }

        function stopMoving() {
            if (moveInterval) {
                clearInterval(moveInterval); // 이전 움직임 중지
                moveInterval = null; // interval 초기화
            }
            moveActionCheck = null; // 현재 방향 초기화
        }

        let lastKeyDirection = null; // 마지막으로 처리된 키 방향

        $(window).keydown(function (e) {
            const $characImg = $('.front_charac_img');
            const chatInputFocused = $('input[name="body"]').is(':focus');  // 채팅 입력창에 포커스가 있는지 확인

            // 채팅창이 포커스 상태일 때는 키보드 이벤트를 무시
            if (chatInputFocused || !windowCheck) {
                return;  // 채팅창에 포커스가 있으면 함수 종료 (키 이벤트 무시)
            }

            const keyMap = {
                37: {direction: 'left', scale: -1},
                38: {direction: 'up'},
                39: {direction: 'right', scale: 1},
                40: {direction: 'down'}
            };

            const keyAction = keyMap[e.keyCode];
            if (keyAction && moveActionCheck !== keyAction.direction) {
                // 중복된 키 입력 방지
                if (lastKeyDirection === keyAction.direction) return;
                lastKeyDirection = keyAction.direction;

                // 방향에 따라 이미지 반전
                if (keyAction.scale !== undefined) {
                    $characImg.css('transform', `scaleX(${keyAction.scale})`);
                }

                // 애니메이션 유지
                $characImg.css('animation', 'move_action' + keyAction.scale + ' 1s linear infinite');

                // 이동 시작
                startMoving(keyAction.direction);
            }

            if (e.keyCode === 13) {
                // 입력 필드가 포커스되어 있을 때만 전송 처리
                if ($('.chat_var').is(':focus')) {
                    e.preventDefault(); // 엔터로 인한 기본 동작(폼 제출 방지)을 막음
                    $(e.target).closest('form').submit();  // 현재 입력 필드와 연결된 폼만 제출
                } else {
                    processItemAction();
                }
            }
        });

        function hiddenAttack() {
            let newDamage = damage;

            if (getRandom(1, 5) === 3) {
                newDamage = Math.floor(damage * 1.5);
            }

            mob2_hp -= newDamage;
            mob3_hp -= newDamage;
            mob4_hp -= newDamage;
            mob5_hp -= newDamage;
            mob6_hp -= newDamage;

            for (let i = 2; i <= 6; i++) {
                damage__motion(i, newDamage);
            }

            if (mob2_hp <= 0 && characRoom > 0) {
                getMoney(2);
                mobHidden(2);
                clearInterval(stop2);
            }

            if (mob3_hp <= 0 && characRoom > 1) {
                getMoney(3);
                mobHidden(3);
                clearInterval(stop3);
            }

            if (mob4_hp <= 0 && characRoom > 2) {
                getMoney(4);
                mobHidden(4);
                clearInterval(stop4);
            }

            if (mob5_hp <= 0 && characRoom > 3) {
                getMoney(5);
                mobHidden(5);
                clearInterval(stop5);
            }

            if (characRoom === 0) {
                if (mob6_hp <= 0) {
                    getMoney(6);
                    mobHidden(6);
                    clearInterval(stop6);
                    showItem();
                }
                BossHpDown();
            }

            showDoor();
            showRandomItem();
        }

        function hiddenAttackMotion() {
            // 이미 추가된 이펙트가 있다면 중복 방지
            if ($('.hidden-weapon-attack-bg').length > 0) return;

            let hiddenAttackImg = '';

            for (let i = 0; i < 64; i++) {
                let randomNum = Math.floor(Math.random() * 4) + 1;
                let className = "hidden-attack" + randomNum;

                hiddenAttackImg += `<img class="${className}" src="https://github.com/user-attachments/assets/4ee56238-45f4-45ef-80b8-40421b7e57e6" alt="히든무기 공격 이펙트">`;
            }

            // 공격 이펙트 추가
            const $effect = $(`
                <div class="hidden-weapon-attack-bg">
                    ${hiddenAttackImg}
                </div>
            `);

            $('.mapBody').append($effect);

            // 2초 뒤 이펙트 제거
            setTimeout(() => {
                $effect.remove();
            }, 2000);
        }

        const $itemText1 = $('.item_text1');
        const $itemText2 = $('.item_text2');

        function processItemAction() {
            // 랜덤 아이템 안내창이 보여지는중인지 확인
            const isRandomItemHidden = $random_item_text.hasClass('hidden');
            const isItemHidden1 = $itemText1.hasClass('hidden');
            const isItemHidden2 = $itemText2.hasClass('hidden');

            // console.log(isItemHidden1 + ', ' + isItemHidden2 + ', ' + characFloor + ', ' + characRoom + ', ' + characWeaponId);
            $alert.addClass('hidden');
            $random_item_text.addClass('hidden');
            $itemText1.addClass('hidden');
            $itemText2.addClass('hidden');

            if (!isRandomItemHidden && randomItem === 3) {
                Item_get();
            } else if (!isItemHidden1 && characFloor !== 1 && characRoom === 0 && characWeaponId < 70) {
                Item_mix();
            } else if (!isItemHidden2 && characFloor !== 1 && characRoom === 0 && characWeaponId >= 70) {
                Item_upgrade();
            } else {
                hide_alert();
            }

        }

        // 키에서 손을 뗄 때 움직임 멈춤
        $(window).keyup(function (e) {
            const $characImg = $('.front_charac_img');
            const chatInputFocused = $('input[name="body"]').is(':focus');  // 채팅 입력창에 포커스가 있는지 확인

            // 채팅창이 포커스 상태일 때는 키보드 이벤트를 무시
            if (chatInputFocused) {
                return;  // 채팅창에 포커스가 있으면 함수 종료 (키 이벤트 무시)
            }

            // 눌렀던 방향키에서 손을 뗐을 때 이동 중지
            if ((e.keyCode === 37 && moveActionCheck === 'left') ||
                (e.keyCode === 38 && moveActionCheck === 'up') ||
                (e.keyCode === 39 && moveActionCheck === 'right') ||
                (e.keyCode === 40 && moveActionCheck === 'down')) {
                lastKeyDirection = null; // 키 입력 상태 초기화
                $characImg.css('animation', 'none');
                stopMoving();
            }

            if (e.keyCode === 65) {
                $characImg.css("transform", "scaleX(-1)");
                attack('A', 1);
            } else if (e.keyCode === 87) {
                attack('W', 1);
            } else if (e.keyCode === 68) {
                $characImg.css("transform", "scaleX(1)");
                attack('D', 1);
            } else if (e.keyCode === 83) {
                attack('S', 1);
            } else if (e.keyCode === 90 && characWeaponId === 0) {
                hiddenAttack();
                hiddenAttackMotion()
            }
        });

        const $touch_left = $('.key-left');
        const $touch_up = $('.key-up');
        const $touch_center = $('.key-center');
        const $touch_right = $('.key-right');
        const $touch_down = $('.key-down');
        const $characImg = $('.front_charac_img');

        const handleTouchStart = (direction, scale) => {
            if (moveActionCheck === direction) return;
            lastKeyDirection = direction;

            if (scale !== undefined) {
                $characImg.css('transform', `scaleX(${scale})`);
            }
            $characImg.css('animation', 'move_action' + scale + ' 1s linear infinite');
            startMoving(direction);
        };

        const handleTouchEnd = (direction) => {
            if (moveActionCheck === direction) {
                lastKeyDirection = null;
                $characImg.css('animation', 'none');
                stopMoving();
            }
        };

        $touch_left.on("touchstart", () => {
            handleTouchStart('left', -1)
        });

        $touch_up.on("touchstart", () => {
            handleTouchStart('up')
        });

        $touch_center.on("touchstart", () => {
            processItemAction();
        });

        $touch_right.on("touchstart", () => {
            handleTouchStart('right', 1)
        });

        $touch_down.on("touchstart", () => {
            handleTouchStart('down')
        });

        $touch_left.on("touchend", () => {
            handleTouchEnd('left')
        });

        $touch_up.on("touchend", () => {
            handleTouchEnd('up')
        });

        $touch_right.on("touchend", () => {
            handleTouchEnd('right')
        });

        $touch_down.on("touchend", () => {
            handleTouchEnd('down')
        });

        const $touch_Aattack = $('.key-Aattack');
        const $touch_Wattack = $('.key-Wattack');
        const $touch_Zattack = $('.key-Zattack');
        const $touch_Dattack = $('.key-Dattack');
        const $touch_Sattack = $('.key-Sattack');

        $touch_Aattack.on("touchstart", () => {
            $characImg.css("transform", "scaleX(-1)");
            attack('A', 1);
        });

        $touch_Wattack.on("touchstart", () => {
            attack('W', 1)
        });

        $touch_Zattack.on("touchstart", () => {
            if (characWeaponId === 0) {
                hiddenAttack();
                hiddenAttackMotion()
            }
        });

        $touch_Dattack.on("touchstart", () => {
            $characImg.css("transform", "scaleX(1)");
            attack('D', 1);
        });

        $touch_Sattack.on("touchstart", () => {
            attack('S', 1)
        });

        function moveCharacter(moveAction, something) {
            // console.log("moveAction :" + moveAction + ", mob : " + "mob" + something);

            if (!windowCheck) return;

            let data = moveCheck(moveAction, something);


            // console.log('moveAction : ' + moveAction + ' / something : ' + something + ' / data : ' + data);

            if (something !== 1 && data === 1) {
                hpDown(mobDamage);
                damage__motion(data, mobDamage);
            } else if (something === 1 && data > 1) {
                hpDown(mobDamage);
                damage__motion(something, mobDamage);
            }

            if (something === 1) {
                if (moveAction === 'up' && UD > 10) {
                    UD -= 2;
                    $(".charac").css("top", UD + "vh");
                } else if (moveAction === 'down' && UD < 80) {
                    UD += 2;
                    $(".charac").css("top", UD + "vh");
                } else if (moveAction === 'left' && LR > 10) {
                    LR -= 2;
                    $(".charac").css("left", LR + "vh");
                } else if (moveAction === 'right' && LR < 80) {
                    LR += 2;
                    $(".charac").css("left", LR + "vh");
                }

                // console.log("UD :" + UD + ", LR : " + LR);
                showDoor();
                stageUp();
                showItem_text();
                showRandomItem_text();
            } else if (something === 2) {
                if (moveAction === 'up' && UD2 > 10) {
                    UD2 -= 2;
                    $(".mob" + something).css("top", UD2 + "vh");
                } else if (moveAction === 'down' && UD2 < 80) {
                    UD2 += 2;
                    $(".mob" + something).css("top", UD2 + "vh");
                } else if (moveAction === 'left' && LR2 > 10) {
                    LR2 -= 2;
                    $(".mob" + something).css("left", LR2 + "vh");
                } else if (moveAction === 'right' && LR2 < 80) {
                    LR2 += 2;
                    $(".mob" + something).css("left", LR2 + "vh");
                }
            } else if (something === 3) {
                if (moveAction === 'up' && UD3 > 10) {
                    UD3 -= 2;
                    $(".mob" + something).css("top", UD3 + "vh");
                } else if (moveAction === 'down' && UD3 < 80) {
                    UD3 += 2;
                    $(".mob" + something).css("top", UD3 + "vh");
                } else if (moveAction === 'left' && LR3 > 10) {
                    LR3 -= 2;
                    $(".mob" + something).css("left", LR3 + "vh");
                } else if (moveAction === 'right' && LR3 < 80) {
                    LR3 += 2;
                    $(".mob" + something).css("left", LR3 + "vh");
                }
            } else if (something === 4) {
                if (moveAction === 'up' && UD4 > 10) {
                    UD4 -= 2;
                    $(".mob" + something).css("top", UD4 + "vh");
                } else if (moveAction === 'down' && UD4 < 80) {
                    UD4 += 2;
                    $(".mob" + something).css("top", UD4 + "vh");
                } else if (moveAction === 'left' && LR4 > 10) {
                    LR4 -= 2;
                    $(".mob" + something).css("left", LR4 + "vh");
                } else if (moveAction === 'right' && LR4 < 80) {
                    LR4 += 2;
                    $(".mob" + something).css("left", LR4 + "vh");
                }
            } else if (something === 5) {
                if (moveAction === 'up' && UD5 > 10) {
                    UD5 -= 2;
                    $(".mob" + something).css("top", UD5 + "vh");
                } else if (moveAction === 'down' && UD5 < 80) {
                    UD5 += 2;
                    $(".mob" + something).css("top", UD5 + "vh");
                } else if (moveAction === 'left' && LR5 > 10) {
                    LR5 -= 2;
                    $(".mob" + something).css("left", LR5 + "vh");
                } else if (moveAction === 'right' && LR5 < 80) {
                    LR5 += 2;
                    $(".mob" + something).css("left", LR5 + "vh");
                }
            } else if (something === 6) {
                if (moveAction === 'up' && UD6 > 10) {
                    UD6 -= 2;
                    $(".mob" + something).css("top", UD6 + "vh");
                } else if (moveAction === 'down' && UD6 < 70) {
                    UD6 += 2;
                    $(".mob" + something).css("top", UD6 + "vh");
                } else if (moveAction === 'left' && LR6 > 10) {
                    LR6 -= 2;
                    $(".mob" + something).css("left", LR6 + "vh");
                } else if (moveAction === 'right' && LR6 < 70) {
                    LR6 += 2;
                    $(".mob" + something).css("left", LR6 + "vh");
                }
            }
        }

        function attack(direction, something) {

            if (!windowCheck) return;

            // 먼저 attack_motion 을 즉시 실행
            attack_motion(something, direction);

            let newDamage = damage;

            if (getRandom(1, 5) === 3) {
                newDamage = Math.floor(damage * 1.5);
            } else if (direction === 'A') {
                newDamage = Math.floor(damage * 2);
            }

            // 나머지 로직은 0.5초 뒤에 실행
            // setTimeout(() => {
            let data = attackCheck(something, direction);
            // console.log(data);
            if (something !== 1 && data === 1) {
                if (something < 6) {
                    hpDown(mobDamage);
                    damage__motion(data, mobDamage);
                } else {
                    hpDown(mobDamage * 2);
                    damage__motion(data, mobDamage * 2);
                }
            } else if (something === 1 && data === 2) {
                mob2_hp -= newDamage;
                damage__motion(data, newDamage);
                if (mob2_hp <= 0) {
                    getMoney(data);
                    mobHidden(data);
                    clearInterval(stop2);
                }
            } else if (something === 1 && data === 3) {
                mob3_hp -= newDamage;
                damage__motion(data, newDamage);
                if (mob3_hp <= 0) {
                    getMoney(data);
                    mobHidden(data);
                    clearInterval(stop3);
                }
            } else if (something === 1 && data === 4) {
                mob4_hp -= newDamage;
                damage__motion(data, newDamage);
                if (mob4_hp <= 0) {
                    getMoney(data);
                    mobHidden(data);
                    clearInterval(stop4);
                }
            } else if (something === 1 && data === 5) {
                mob5_hp -= newDamage;
                damage__motion(data, newDamage);
                if (mob5_hp <= 0) {
                    getMoney(data);
                    mobHidden(data);
                    clearInterval(stop5);
                }
            } else if (something === 1 && data === 6) {
                mob6_hp -= newDamage;
                damage__motion(data, newDamage);
                if (mob6_hp <= 0) {
                    getMoney(data);
                    mobHidden(data);
                    clearInterval(stop6);
                    showItem();
                }
                BossHpDown();
            }
            if (something === 1) {
                showDoor();
                showRandomItem();
            }
            // }, 400);
        }

        function mobMeleeAttack(something) {
            if (!windowCheck) return;
            
            // 먼저 melee_Attack_motion 을 즉시 실행
            melee_Attack_motion(something);

            let data = meleeAttackCheck(something);

            if (something !== 1 && data === 1) {
                if (something < 6) {
                    hpDown(mobDamage);
                    damage__motion(data, mobDamage);
                } else {
                    hpDown(mobDamage * 2);
                    damage__motion(data, mobDamage * 2);
                }
            }
        }

        let mobBombAttackCheck = {};

        function mobBombAttack(something) {
            if (!windowCheck) return;

            if (mobBombAttackCheck[something]) return;
            mobBombAttackCheck[something] = true;

            // 먼저 bomb_Attack_motion 을 즉시 실행
            bomb_Attack_motion(something);

            // 2초뒤에 실행
            setTimeout(() => {
                let data = bombAttackCheck(something);

                if (something !== 1 && data === 1) {
                    if (something < 6) {
                        hpDown(mobDamage);
                        damage__motion(data, mobDamage);
                    } else {
                        hpDown(mobDamage * 2);
                        damage__motion(data, mobDamage * 2);
                    }
                }

                mobBombAttackCheck[something] = false;
            }, 2000);
        }

        function beamAttack(direction, something) {
            if (!windowCheck) return;

            // 먼저 attack_motion 을 즉시 실행
            beamAttack_motion(something, direction);

            // 0.5초뒤에 실행
            setTimeout(() => {
                let data = beamAttackCheck(something, direction);

                if (something !== 1 && data === 1) {
                    if (something < 6) {
                        hpDown(mobDamage);
                        damage__motion(data, mobDamage);
                    } else {
                        hpDown(mobDamage * 2);
                        damage__motion(data, mobDamage * 2);
                    }
                }

                mobBombAttackCheck[something] = false;
            }, 500);
        }

        let saveCooldown = false; // 저장 쿨타임 변수

        async function saveLog() {
            if (saveCooldown) return; // 쿨타임 중이면 저장하지 않음

            saveCooldown = true;  // 저장 시작

            try {
                await saveFirebaseLogs(charac, seconds);
                await playStatsUpdate(nickname, front_money);
                await characReset(nickname);
                // 비동기 작업 완료될 때까지 기다림
            } catch (error) {
                console.error("로그 저장 중 오류 발생:", error);
            } finally {
                saveCooldown = false; // 작업이 끝나면 쿨타임 해제
                location.href = '../over';
            }
        }

        // hp 감소
        async function hpDown(mobDamage) {
            front_hp -= mobDamage;
            $hp_count.text(front_hp);
            characHpDown();
            if (front_hp <= 0) {
                await saveLog();
            }
        }

        // 캐릭 체력바 변화 함수
        function characHpDown() {
            let new_characHp_width = (8 / 100) * (front_hp % 100);
            // console.log(new_characHp_width);
            let characHp_number = Math.floor(front_hp / 100);
            if (front_hp % 100 === 0) {
                new_characHp_width = 8;
                characHp_number--;
            }
            // console.log("체력 넓이 : " + new_characHp_width + ", 줄 수 : " + characHp_number);
            for (let i = characHp_number - 1; i >= 0; i--) {
                $(".characHP_bar" + i).css('width', '8vh');
            }
            for (let i = characHp_number + 1; i < 11; i++) {
                $(".characHP_bar" + i).css('width', '0vh');
            }

            // console.log(".characHP_bar"+(characHp_number-1));
            $(".characHP_bar" + characHp_number).css('width', new_characHp_width + 'vh');
            $(".characHP_bar_text").text('x' + (characHp_number + 1));
        }

        const getMoneyCheck = {};

        // 돈 획득시 증가 함수
        function getMoney(data) {
            // 이미 돈을 획득한적이 있는지 체크
            if (getMoneyCheck[data]) return;

            // 획득 완료 처리
            getMoneyCheck[data] = true;

            if (data < 6) {
                front_money++;
            } else if (data === 6) {
                front_money += 10;
            }
            $money_count.text(front_money);
        }

        const mobHiddenCheck = {};

        //몬스터 사라지게하는 함수
        function mobHidden(num) {
            // 이미 행동한적 있는지 체크
            if (mobHiddenCheck[num]) return;

            // 완료 처리
            mobHiddenCheck[num] = true;

            let $mob = $(".mob" + num);
            if (num < 6) {
                let goldDropNum = getRandom(1, 4);
                $mob.append(`
                    <img class="gold goldDrop-${goldDropNum}" src="https://github.com/user-attachments/assets/6acb19ee-b422-47bd-ba63-7ceb0b7610f5"
                         alt=""/>
                `)
            } else if (num === 6) {
                $mob.append(`
                    <img class="gold goldDrop-1" src="https://github.com/user-attachments/assets/6acb19ee-b422-47bd-ba63-7ceb0b7610f5"
                         alt=""/>
                    <img class="gold goldDrop-2" src="https://github.com/user-attachments/assets/6acb19ee-b422-47bd-ba63-7ceb0b7610f5"
                         alt=""/>
                    <img class="gold goldDrop-3" src="https://github.com/user-attachments/assets/6acb19ee-b422-47bd-ba63-7ceb0b7610f5"
                         alt=""/>
                    <img class="gold goldDrop-4" src="https://github.com/user-attachments/assets/6acb19ee-b422-47bd-ba63-7ceb0b7610f5"
                         alt=""/>
                `)
            }

            $mob.fadeOut(2000, function () {
                $(this).addClass('hidden');
            });
        }

        function moveCheck(moveAction, something) {
            let Xcode = somethingXcode(something) - 5;
            let Ycode = somethingYcode(something) - 5;
            let height = something > 5 ? 10 : 5;
            let width = something > 5 ? 10 : 5;

            // 맵 생성
            const map2 = mapCheck(something);

            // for (i = 0; i < 40; i++) {
            //    let log = '';
            //    for (j = 0; j < 40; j++) {
            //        log += '[' + map2[i][j] + ']';
            //    }
            //    console.log(log);
            //}

            // something 주위 공간 확인
            if (moveAction === 'up') {
                for (let y = Ycode; y < Ycode + width && y < 40; y++) {
                    if (Xcode - 1 >= 0 && map2[Xcode - 1][y] !== 0) {
                        return map2[Xcode - 1][y];
                    }
                }
            } else if (moveAction === 'down') {
                for (let y = Ycode; y < Ycode + width && y < 40; y++) {
                    if (Xcode + height < 40 && map2[Xcode + height][y] !== 0) {
                        return map2[Xcode + height][y];
                    }
                }
            } else if (moveAction === 'left') {
                for (let x = Xcode; x < Xcode + height && x < 40; x++) {
                    if (Ycode - 1 >= 0 && map2[x][Ycode - 1] !== 0) {
                        return map2[x][Ycode - 1];
                    }
                }
            } else if (moveAction === 'right') {
                for (let x = Xcode; x < Xcode + height && x < 40; x++) {
                    if (Ycode + width < 40 && map2[x][Ycode + width] !== 0) {
                        return map2[x][Ycode + width];
                    }
                }
            }

            return 0;
        }

        // 공격 대상 확인 함수
        function attackCheck(something, direction) {
            let Xcode = somethingXcode(something) - 5;
            let Ycode = somethingYcode(something) - 5;
            let height = something > 5 ? 8 : 4;
            let width = something > 5 ? 8 : 4;

            // console.log('Xcode : ' + Xcode);
            // console.log('Ycode : ' + Ycode);

            let distance = somethingDistance(something, front_weaponId, characFloor, characRoom);

            // console.log('something : ' + something);

            // 맵 생성
            const map3 = mapCheck(something);

            if (direction === 'A') {
                let x = Xcode + (height / 2);
                let y = Ycode - distance;
                // console.log('x : ' + x);
                // console.log('y : ' + y);

                for (let i = Ycode - 1; i > y && i >= 0; i--) {
                    if (map3[x][i] !== 0) {
                        return map3[x][i];
                    }
                }
            } else if (direction === 'W') {
                let x = Xcode - distance;
                let y = Ycode + (width / 2);
                // console.log('x : ' + x);
                // console.log('y : ' + y);

                for (let i = Xcode - 1; i > x && i >= 0; i--) {
                    if (map3[i][y] !== 0) {
                        return map3[i][y];
                    }
                }
            } else if (direction === 'D') {
                let x = Xcode + (height / 2);
                let y = Ycode + width + distance;
                // console.log('x : ' + x);
                // console.log('y : ' + y);

                for (let i = Ycode + width; i < y && i < 40; i++) {
                    if (map3[x][i] !== 0) {
                        return map3[x][i];
                    }
                }
            } else if (direction === 'S') {
                let x = Xcode + height + distance;
                let y = Ycode + (width / 2);
                // console.log('x : ' + x);
                // console.log('y : ' + y);

                for (let i = Xcode + height; i < x && i < 40; i++) {
                    if (map3[i][y] !== 0) {
                        return map3[i][y];
                    }
                }
            }
            return 0;
        }

        function meleeAttackCheck(something) {
            let Xcode = somethingXcode(something) - 5;
            let Ycode = somethingYcode(something) - 5;
            let height = something > 5 ? 8 : 4;
            let width = something > 5 ? 8 : 4;

            const map4 = mapCheck(something);

            let x = Xcode;
            let y = Ycode - 1;

            for (let i = 0; i < height; i++) {
                x++;
                y--;
                if (map4[x][y] !== 0) {
                    return map4[x][y];
                }
            }
        }

        function bombAttackCheck(something) {
            let Xcode = somethingXcode(something) - 5;
            let Ycode = somethingYcode(something) - 5;
            let height = something > 5 ? 10 : 5;
            let width = something > 5 ? 10 : 5;

            const map5 = mapCheck(something);

            let x = Xcode - width;
            let y = Ycode - height;

            for (let i = 0; i < height * 3; i++) {
                for (let j = 0; j < width * 3; j++) {
                    const xi = x + i;
                    const yj = y + j;
                    if (xi >= 0 && xi < 40 && yj >= 0 && yj < 40 && map5[xi][yj] !== 0) {
                        console.log(`map5[${xi}][${yj}] =`, map5[xi][yj]);
                        return map5[xi][yj];
                    }
                }
            }
        }

        function beamAttackCheck(something, direction) {
            let Xcode = somethingXcode(something) - 5;
            let Ycode = somethingYcode(something) - 5;
            let offset = something > 5 ? 7 : 4;

            const map6 = mapCheck(something);

            // console.log(`${Xcode}, ${Ycode}`);

            if (direction === 'A') {
                for (let i = Ycode; i >= 0; i--) {
                    for (let j = 1; j < offset; j++) {
                        if (map6[Xcode + j][i] === 1) {
                            return 1;
                        }
                    }
                }
            } else if (direction === 'D') {
                for (let i = Ycode; i < 40; i++) {
                    for (let j = 1; j < offset; j++) {
                        if (map6[Xcode + j][i] === 1) {
                            return 1;
                        }
                    }
                }
            } else if (direction === 'W') {
                for (let i = Xcode; i >= 0; i--) {
                    for (let j = 1; j < offset; j++) {
                        if (map6[i][Ycode + j] === 1) {
                            return 1;
                        }
                    }
                }
            } else if (direction === 'S') {
                for (let i = Xcode; i < 40; i++) {
                    for (let j = 1; j < offset; j++) {
                        if (map6[i][Ycode + j] === 1) {
                            return 1;
                        }
                    }
                }
            }
        }

        // 아이템 안내창 공개
        function showItem_text() {
            let itemCheck = $item.hasClass('hidden');
            // console.log("아이템 공개 여부"+itemCheck);
            if (LR > 64 && LR < 76 && UD < 56 && UD > 34 && !itemCheck && characFloor > 1 && characRoom === 0) {
                $item_text.fadeIn(1000).removeClass('hidden');
            }
        }

        // 아이템 공개
        function showItem() {
            $item.fadeIn(1000).removeClass('hidden');
        }

        // 랜덤아이템 안내창 공개
        function showRandomItem_text() {
            let randomItemCheck = $random_item.hasClass('hidden');
            // console.log("아이템 공개 여부"+itemCheck);
            if (UD > 64 && UD < 76 && LR < 56 && LR > 34 && !randomItemCheck) {
                $random_item_text.fadeIn(1000).removeClass('hidden');
            }
        }

        let isItem = true;

        function showRandomItem() {
            const isSpecialRoom = (characFloor === 8 && characRoom === 0);
            const allMobsDefeated = (mob2_hp <= 0 && mob3_hp <= 0 && mob4_hp <= 0 && mob5_hp <= 0 && mob6_hp <= 0);
            const isSpecialItem = (randomItem === 3);
            const isExcludedRoom = (characFloor === 1 && characRoom === 0);

            if (!isExcludedRoom && allMobsDefeated && isSpecialItem && (isSpecialRoom || isItem)) {
                isItem = false;
                $random_item.fadeIn(1000).removeClass('hidden');
            }
        }

        function somethingXcode(something) {
            if (something === 1) return UD / 2;
            else if (something === 2) return UD2 / 2;
            else if (something === 3) return UD3 / 2;
            else if (something === 4) return UD4 / 2;
            else if (something === 5) return UD5 / 2;
            else if (something === 6) return UD6 / 2;
            return 0;
        }

        function somethingYcode(something) {
            if (something === 1) return LR / 2;
            else if (something === 2) return LR2 / 2;
            else if (something === 3) return LR3 / 2;
            else if (something === 4) return LR4 / 2;
            else if (something === 5) return LR5 / 2;
            else if (something === 6) return LR6 / 2;
            return 0;
        }

        function mapCheck(something) {
            let characXCode = (UD / 2) - 5;
            let characYCode = (LR / 2) - 5;
            let mob2XCode = (UD2 / 2) - 5;
            let mob2YCode = (LR2 / 2) - 5;
            let mob2life = mob2_hp > 0;
            let mob3XCode = (UD3 / 2) - 5;
            let mob3YCode = (LR3 / 2) - 5;
            let mob3life = mob3_hp > 0;
            let mob4XCode = (UD4 / 2) - 5;
            let mob4YCode = (LR4 / 2) - 5;
            let mob4life = mob4_hp > 0;
            let mob5XCode = (UD5 / 2) - 5;
            let mob5YCode = (LR5 / 2) - 5;
            let mob5life = mob5_hp > 0;
            let mob6XCode = (UD6 / 2) - 5;
            let mob6YCode = (LR6 / 2) - 5;
            let mob6life = mob6_hp > 0;
            let floor = characFloor;
            let room = characRoom;

            let rows = 40;
            let cols = 40;

            const map = new Array(rows).fill(null).map(() => new Array(cols).fill(0));

            // 캐릭터 위치 부여
            if (something !== 1) {
                for (let x = characXCode; x < characXCode + 5; x++) {
                    for (let y = characYCode; y < characYCode + 5; y++) {
                        map[x][y] = 1;
                    }
                }
            }

            // 몬스터 위치 부여
            if (room > 0 && room < 5 && mob2life && something !== 2) {
                for (let x = mob2XCode; x < mob2XCode + 5; x++) {
                    for (let y = mob2YCode; y < mob2YCode + 5; y++) {
                        map[x][y] = 2;
                    }
                }
            }
            if (room > 1 && room < 5 && mob3life && something !== 3) {
                for (let x = mob3XCode; x < mob3XCode + 5; x++) {
                    for (let y = mob3YCode; y < mob3YCode + 5; y++) {
                        map[x][y] = 3;
                    }
                }
            }
            if (room > 2 && room < 5 && mob4life && something !== 4) {
                for (let x = mob4XCode; x < mob4XCode + 5; x++) {
                    for (let y = mob4YCode; y < mob4YCode + 5; y++) {
                        map[x][y] = 4;
                    }
                }
            }
            if (room > 3 && room < 5 && mob5life && something !== 5) {
                for (let x = mob5XCode; x < mob5XCode + 5; x++) {
                    for (let y = mob5YCode; y < mob5YCode + 5; y++) {
                        map[x][y] = 5;
                    }
                }
            }
            if (floor > 1 && room === 0 && mob6life && something !== 6) {
                for (let x = mob6XCode; x < mob6XCode + 10; x++) {
                    for (let y = mob6YCode; y < mob6YCode + 10; y++) {
                        map[x][y] = 6;
                    }
                }
            }
            return map;
        }

        function somethingDistance(something, weaponId, floor, room) {
            if (something === 1) {
                if (weaponId % 10 === 1) {
                    return 4;
                } else if (weaponId % 10 === 2) {
                    return 5;
                } else if (weaponId % 10 === 3) {
                    return 6;
                } else if (weaponId % 10 === 4) {
                    return 7;
                } else if (weaponId % 10 === 5) {
                    return 8;
                } else if (weaponId % 10 === 6) {
                    return 9;
                } else if (weaponId % 10 === 7) {
                    return 10;
                } else if (weaponId % 10 === 8) {
                    return 11;
                } else if (weaponId % 10 === 9) {
                    return 12;
                } else if (weaponId % 10 === 0) {
                    return 13;
                }
            } else {
                if (room === 0) {
                    return 13;
                } else if (floor % 10 == 1) {
                    return 4;
                } else if (floor % 10 == 2) {
                    return 5;
                } else if (floor % 10 == 3) {
                    return 6;
                } else if (floor % 10 == 4) {
                    return 7;
                } else if (floor % 10 == 5) {
                    return 8;
                } else if (floor % 10 == 6) {
                    return 9;
                } else if (floor % 10 == 7) {
                    return 10;
                } else if (floor % 10 == 8) {
                    return 11;
                } else if (floor % 10 == 9) {
                    return 12;
                } else {
                    return 13;
                }
            }
        }

        // 공격 모션 실행 함수
        function attack_motion(something, motion) {
            let Distance = 0;

            // console.log(front_weaponId);

            if (something === 1) {
                Distance = front_weaponId % 10; // 소수점 아래 버림
                if (front_weaponId % 10 === 0) {
                    Distance = 10;
                }
            } else {
                Distance = characFloor % 10 == 0 ? 10 : characFloor % 10;
                if (Distance > 10 || characRoom === 0) {
                    Distance = 10;
                }
            }

            const weaponImg = something === 1
              ? weapon[front_weaponId]
              : "https://github.com/user-attachments/assets/49ac96a1-55f9-4b50-a4fe-c2107f21c2a1";

            let $attackElement = $(`<img class="weapon_img attackSize attack${something} absolute" src="${weaponImg}" alt=""/>`);

            if (something === 1) {
                $('.front_charac').append($attackElement);
            } else {
                $(`.mob${something}`).append($attackElement);
            }

            // 약간의 딜레이 후에 css 를 변경해 이동하는 모습을 표현
            setTimeout(function () {
                if (motion === 'A') {
                    $attackElement.css({
                        left: (-4 - (Distance * 2)) + "vh",
                        transform: "scaleX(-1)"
                    });
                } else if (motion === 'W') {
                    $attackElement.css({
                        top: (-4 - (Distance * 2)) + "vh",
                        transform: "rotate(270deg)"
                    });
                } else if (motion === 'D') {
                    if (something < 6) {
                        $attackElement.css('left', (12 + (Distance * 2)) + "vh");
                    } else if (something === 6) {
                        $attackElement.css('left', (22 + (Distance * 2)) + "vh");
                    }
                } else if (motion === 'S') {
                    if (something < 6) {
                        $attackElement.css({
                            top: (12 + (Distance * 2)) + "vh",
                            transform: "rotate(90deg)"
                        });
                    } else if (something === 6) {
                        $attackElement.css({
                            top: (22 + (Distance * 2)) + "vh",
                            transform: "rotate(90deg)"
                        });
                    }
                }
            }, 10);  // 10ms 정도의 짧은 딜레이를 줘서 CSS 변경을 애니메이션으로 적용

            // 0.5초 뒤에 애니메이션이 끝나고 제거
            setTimeout(function () {
                $attackElement.remove();
            }, 500);  // 애니메이션 시간 500ms 이후
        }

        function melee_Attack_motion(something) {
            const $meleeAttackElement = $(".meleeAttack" + something);

            $meleeAttackElement.css({
                "transform-origin": "bottom center", // 아래를 중심으로 회전
                transform: "rotate(-90deg)",
                transition: "transform 0.2s ease"
            });

            setTimeout(() => {
                $meleeAttackElement.css({
                    transform: "rotate(0deg)",
                    transition: "transform 0.2s ease"
                });
            }, 500);
        }

        function bomb_Attack_motion(something) {
            const $target = $(`.mob${something}`);

            $target.append(`
                <img class="bombAttack${something} absolute" src="https://github.com/user-attachments/assets/88577ab9-8cf6-4bde-9aa9-cf0b73104ae2" alt="">
            `);

            // 3초 뒤 폭탄 이미지를 터지는 이미지로 변경
            setTimeout(() => {
                $target.find(`.bombAttack${something}`).remove();
                let boomAttackImg = "";

                for (let i = 0; i < 25; i++) {
                    let randomNum = Math.floor(Math.random() * 2) + 1;
                    let className = "boom-attack" + something + "-" + randomNum;

                    boomAttackImg += `<img class="${className}" src="https://github.com/user-attachments/assets/f9136a53-b517-45dd-a049-b821b1663361" alt="폭발(불꽃) 이미지">`;
                }

                const $effect = $(`
                    <div class="boom-attack-bg${something} absolute">
                        ${boomAttackImg}
                    </div>
                `);

                $target.append($effect);

                // 추가한 이펙트는 1초 뒤 제거
                setTimeout(() => {
                    $effect.remove();
                }, 1000);

            }, 2000);
        }

        $(window).keyup(function (e) {
            if (e.keyCode === 88) {

            }
            if (e.keyCode === 67) {

            }
            if (e.keyCode === 86) {

            }
            if (e.keyCode === 66) {

            }
        });

        function beamAttack_motion(something, motion) {
            const UDMap = { 2: UD2, 3: UD3, 4: UD4, 5: UD5, 6: UD6 };
            const LRMap = { 2: LR2, 3: LR3, 4: LR4, 5: LR5, 6: LR6 };
            const UDOffset = UDMap[something];
            const LROffset = LRMap[something];

            const xOffset = something === 6 ? 4 : 2;
            const yOffset = something === 6 ? 8 : 4;

            let $attackElement = $(`<img class="beamAttack${something}" src="https://github.com/user-attachments/assets/204705f9-7cf4-4334-a01e-6bd4cca50835" alt=""/>`);
            $(".mapBody").append($attackElement);

            const topValue = `${UDOffset + xOffset}vh`;
            const rightValue = `${100 - (LROffset + yOffset)}vh`;
            const leftValue = `${LROffset + yOffset}vh`;

            let styles = {
                top: topValue,
                'object-fit': 'cover',
                'object-position': 'left'
            };
            let animationWidth;

            if (motion === 'A') {
                styles.right = rightValue;
                animationWidth = `${LROffset}vh`;
            } else if (motion === 'D') {
                styles.left = leftValue;
                styles.transform = 'scaleX(-1)';
                animationWidth = `${100 - LROffset - (yOffset * 2)}vh`;
            } else if (motion === 'S') {
                styles.right = rightValue;
                styles.transform = 'rotate(270deg)';
                styles['transform-origin'] = 'right center';
                animationWidth = `${100 - UDOffset - (yOffset * 2)}vh`;
            } else if (motion === 'W') {
                styles.right = rightValue;
                styles.transform = 'rotate(90deg)';
                styles['transform-origin'] = 'right center';
                animationWidth = `${UDOffset}vh`;
            }

            $attackElement.css(styles).animate({
                width: animationWidth
            }, 500, () => {
                setTimeout(() => {
                    $attackElement.remove();
                });
            });
        }

        let isConfirm = true; // 알림창 중복 방지 플래그

        // 스테이지 이동
        async function stageUp(callback) {

            const doorRightCheck = $(".door_right").hasClass("hidden");
            const doorTopCheck = $(".door_top").hasClass("hidden");
            const doorBottomCheck = $(".door_bottom").hasClass("hidden");

            let doorCheck = 'right';

            // console.log(`LR : ${LR}, UD : ${UD}`);

            if ((LR > 79 && 38 < UD && UD < 52) && !doorRightCheck) {
                doorCheck = 'right';
            } else if ((UD <= 10 && 38 < LR && LR < 52) && !doorTopCheck) {
                doorCheck = 'top';
            } else if ((UD > 79 && 38 < LR && LR < 52) && !doorBottomCheck) {
                doorCheck = 'bottom';
            } else if (callback)  {
                console.log('확인');
            } else return;

            stopMoving();
            const isItemHidden = $item.hasClass('hidden');
            if (!isItemHidden && isConfirm && characFloor <= 5) {
                console.log('2단계 진입' + isConfirm);
                // isConfirm이 true일 때만 confirm() 실행
                if (!confirm('무기를 획득하지 않았습니다. 그래도 이동하시겠습니까?')) {
                    console.log('3단계 진입' + isConfirm);
                    isConfirm = false; // 취소한 경우, 이동하지 않음
                    return;
                } else {
                    console.log('4단계 진입' + isConfirm);
                    await stageSave(callback, nickname, characFloor, characRoom, front_hp, front_power, front_speed, front_money, front_weaponId, front_weaponUpgrade, seconds, doorCheck);
                }
            } else if (!isConfirm && characFloor <= 5) {
                console.log('5단계 진입' + isConfirm);
                await stageSave(callback, nickname, characFloor, characRoom, front_hp, front_power, front_speed, front_money, front_weaponId, front_weaponUpgrade, seconds, doorCheck);
            } else if (characFloor > 5) {
                console.log('6단계 진입' + isConfirm);
                await stageSave(callback, nickname, characFloor, characRoom, front_hp, front_power, front_speed, front_money, front_weaponId, front_weaponUpgrade, seconds, doorCheck);
            } else if (isItemHidden) {
                console.log('7단계 진입' + isConfirm);
                await stageSave(callback, nickname, characFloor, characRoom, front_hp, front_power, front_speed, front_money, front_weaponId, front_weaponUpgrade, seconds, doorCheck);
            }
            await stageSave(callback, nickname, characFloor, characRoom, front_hp, front_power, front_speed, front_money, front_weaponId, front_weaponUpgrade, seconds, doorCheck);

            if (callback) callback(); // 조건이 안 맞아도 실행
        }

        // 버튼 클릭 시 스테이지 업 후 페이지 이동
        $(".mob__list_bt").on("click", function () {
            stageUp(function () {
                location.href = '../dictionary/mob.html';
            });
        });

        $(".weapon__list_bt").on("click", function () {
            stageUp(function () {
                location.href = '../dictionary/weapon.html';
            });
        });

        // 데미지 화면에 보여주기
        function damage__motion(data, newDamage) {
            // console.log(data, newDamage)
            newDamage = newDamage > damage ? `Critical<br>${newDamage}` : newDamage;

            mobHpDown(data);

            $(".damage" + data).html(newDamage);
            setTimeout(function () {
                $(".damage" + data).html('');
            }, 1000);
        }

        // 몬스터 체력바 변화 함수
        function mobHpDown(something) {
            let mob_hp = 0;
            if (something === 2) {
                mob_hp = mob2_hp;
            } else if (something === 3) {
                mob_hp = mob3_hp;
            } else if (something === 4) {
                mob_hp = mob4_hp;
            } else if (something === 5) {
                mob_hp = mob5_hp;
            }
            let new_mobHp_width = (8 / (characFloor * 10)) * mob_hp;
            if (mob_hp <= 0) new_mobHp_width = 0;
            $(".mob" + something + "HP_bar").css('width', new_mobHp_width + 'vh');
        }

        // 보스 체력바 변화 함수
        function BossHpDown() {
            let new_bossHp_width = (50 / ((characFloor - 1) * 100) * mob6_hp);
            if (mob6_hp <= 0) new_bossHp_width = 0;
            $(".bossHP_bar").css('width', new_bossHp_width + 'vh');
        }

        // 몬스터 hp 셋팅
        let mob2_hp = 0;
        let mob3_hp = 0;
        let mob4_hp = 0;
        let mob5_hp = 0;
        let mob6_hp = 0;

        // 몬스터의 체력 부여
        if (characRoom > 0 && characRoom < 5) {
            $('.mob2').removeClass('hidden');
            mob2_hp = characFloor * 10;
        }
        if (characRoom > 1 && characRoom < 5) {
            $('.mob3').removeClass('hidden');
            mob3_hp = characFloor * 10;
        }
        if (characRoom > 2 && characRoom < 5) {
            $('.mob4').removeClass('hidden');
            mob4_hp = characFloor * 10;
        }
        if (characRoom > 3 && characRoom < 5) {
            $('.mob5').removeClass('hidden');
            mob5_hp = characFloor * 10;
        }
        if (characFloor > 1 && characRoom === 0) {
            $('.mob6').removeClass('hidden');
            $('.bossHP').removeClass('hidden');
            mob6_hp = (characFloor - 1) * 100;
        }

        // 자동 실행 move 함수 담아놓을 변수 생성
        let stop2, stop3, stop4, stop5, stop6;

        //일정 시간마다 move 함수를 호출
        function show() {
            console.log("페이지가 모두 로드된 후 실행됩니다.");
            // console.log(((8 / 100) * front_hp));

            setTimeout(characHpDown, 1000);
            setTimeout(() => mobHpDown(2), 1000);
            setTimeout(() => mobHpDown(3), 1000);
            setTimeout(() => mobHpDown(4), 1000);
            setTimeout(() => mobHpDown(5), 1000);
            $('body').css('cursor', 'none');


            if (characRoom > 0 && characRoom < 5) {
                stop2 = setInterval(() => move(2), 1000);
            }
            if (characRoom > 1 && characRoom < 5) {
                stop3 = setInterval(() => move(3), 800);
            }
            if (characRoom > 2 && characRoom < 5) {
                stop4 = setInterval(() => move(4), 500);
            }
            if (characRoom > 3 && characRoom < 5) {
                stop5 = setInterval(() => move(5), 200);
            }
            if (characFloor > 1 && characRoom === 0) {
                stop6 = setInterval(() => move(6), 200);
            }
        }

        // 랜덤 행동을 사용하는 함수
        function move(something) {
            let random;
            // 1에서 5까지의 랜덤 숫자 생성
            if (characFloor <= 10) {
                random = getRandom(1, 4);
            } else if (characFloor <= 50) {
                random = getRandom(1, 5);
            } else {
                random = getRandom(1, 8);
            }

            // console.log('random : ' + random);
            // console.log('windowCheck : ' + windowCheck);
            // console.log('something : ' + something);

            if (random === 1) {
                moveCharacter('left', something)
            } else if (random === 2) {
                moveCharacter('up', something)
            } else if (random === 3) {
                moveCharacter('right', something)
            } else if (random === 4) {
                moveCharacter('down', something)
            } else if (random === 5 && characFloor <= 20) {
                mobMeleeAttack(something);
            } else if (random === 5 && characFloor <= 30) {
                mobBombAttack(something);
            } else if (random === 5 && characFloor <= 40) {
                mobAttack(something);
            } else if (random === 5 && characFloor <= 50) {
                mobBeamAttack(something);
            } else if (random === 5 && characFloor > 50) {
                $(`.meleeAttack${something}`).remove();
                $(`.mob${something}`).append(`
                    <img class="meleeAttack meleeAttack${something} absolute" src="https://github.com/user-attachments/assets/77b4280b-1541-43d0-9659-c6ef81c1cea0" alt="몬스터 무기${something}"/>
                `);
                setTimeout(() => {
                    mobMeleeAttack(something);
                }, 500);
                setTimeout(() => {
                    $(`.meleeAttack${something}`).remove();
                }, 1000);
            } else if (random === 6 && characFloor > 50) {
                mobBombAttack(something);
            } else if (random === 7 && characFloor > 50) {
                mobAttack(something);
            } else if (random === 8 && characFloor > 50) {
                mobBeamAttack(something);
            }
        }

        // 몬스터의 공격
        function mobAttack(something) {
            let randomAttack = getRandom(1, 4);
            if (randomAttack === 1) {
                attack('A', something);
            } else if (randomAttack === 2) {
                attack('W', something);
            } else if (randomAttack === 3) {
                attack('D', something);
            } else if (randomAttack === 4) {
                attack('S', something);
            }
        }

        // 몬스터의 공격
        function mobBeamAttack(something) {
            let randomAttack = getRandom(1, 4);
            if (randomAttack === 1) {
                beamAttack('A', something);
            } else if (randomAttack === 2) {
                beamAttack('W', something);
            } else if (randomAttack === 3) {
                beamAttack('D', something);
            } else if (randomAttack === 4) {
                beamAttack('S', something);
            }
        }

        // 문 개방
        function showDoor() {
            if (mob2_hp <= 0 && mob3_hp <= 0 && mob4_hp <= 0 && mob5_hp <= 0 && mob6_hp <= 0) {
                const doorsToShow = [];
                const floorMod = characFloor % 6;

                if (characFloor === 1 && characRoom === 0) {
                    doorsToShow.push('.door_right');
                } else if (characRoom === 1) {
                    doorsToShow.push('.door_top', '.door_right', '.door_bottom');
                } else if (characRoom === 2) {
                    const room2Map = [
                        ['.door_top', '.door_right'],
                        ['.door_top', '.door_bottom'],
                        ['.door_right', '.door_bottom'],
                        ['.door_top', '.door_right'],
                        ['.door_right', '.door_bottom'],
                        ['.door_top', '.door_bottom'],
                    ];
                    doorsToShow.push(...room2Map[floorMod]);
                } else {
                    const otherMap = [
                        ['.door_right'],
                        ['.door_bottom'],
                        ['.door_bottom'],
                        ['.door_top'],
                        ['.door_right'],
                        ['.door_top'],
                    ];
                    doorsToShow.push(...otherMap[floorMod]);
                }

                doorsToShow.forEach(selector => {
                    $(selector).fadeIn(1000).removeClass('hidden');
                });
            }
        }

        let timeoutId;

        // 마우스가 움직이면 호출되는 함수
        function resetCursorTimer() {
            // 커서를 다시 보이도록 설정
            $('body').css('cursor', 'default');

            // 이전 타이머가 있다면 취소
            clearTimeout(timeoutId);

            // 설정한 시간 후에 커서를 숨김
            timeoutId = setTimeout(function () {
                $('body').css('cursor', 'none');
            }, 1000);
        }

        // 페이지가 처음 로드될 때 타이머 시작
        timeoutId = setTimeout(function () {
            $('body').css('cursor', 'none');
        }, 3000);

        // 마우스가 움직일 때마다 타이머를 리셋
        $(document).on('mousemove', resetCursorTimer);

        show();

        getWeaponFind(nickname);
    }
}

// 페이지가 시작될 때 시간 기록
const startTime = new Date().getTime();
let estimatedLoadTime = 1500; // 예상 로드 시간

// 페이지 로딩 중에 로딩 바가 점진적으로 증가하도록 설정
const interval = setInterval(function () {
    const currentTime = new Date().getTime();
    const elapsedTime = currentTime - startTime;

    // 경과된 시간에 비례해 로딩 바 너비 설정 (최대 80vh)
    const width = Math.min((elapsedTime / estimatedLoadTime) * 80, 80);
    $(".loading_bar").css("width", width + "vh");

    // 페이지가 로드되기 전에 80vh에 도달하지 않도록 안전하게 제한
    if (width >= 80) {
        clearInterval(interval); // 최대 너비에 도달하면 애니메이션 정지
    }
}, 100); // 100ms 마다 로딩 바 업데이트

// 윈도우 로딩 체크
let windowCheck = false;

// window.onload 이벤트 감지
window.onload = function () {
    // console.clear();
    const loadTime = new Date().getTime() - startTime;

    if (characFloor >= 0) {
        startTimer();
        updateTime();
    }

    // 실제 로드 시간이 예상 시간을 초과하지 않으면, 비율로 로딩 바 채우기
    const finalWidth = Math.min((loadTime / estimatedLoadTime) * 80, 80);
    $(".loading_bar").css("width", finalWidth + "vh");

    // 로딩 바가 완료된 후 로딩 화면 서서히 제거
    setTimeout(function () {
        $(".loading").fadeOut(500);
    }, 500);  // 로드가 완료되면 잠시 후 로딩 화면 제거

    setTimeout(function () {
        windowCheck = true;
    }, 1000);
}

function updateTime() {
    const hrs = Math.floor(seconds / 3600);
    const mins = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;

    // 1초 단위로 형식화
    $(".time").text(
        hrs.toString().padStart(2, '0') + ":" +
        mins.toString().padStart(2, '0') + ":" +
        secs.toString().padStart(2, '0')
    );
}

function startTimer() {
    setInterval(() => {
        seconds++;
        updateTime();
    }, 1000);
}

// 랜덤 수 불러오는 함수 생성
function getRandom(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function weapon_img(img) {
    $weapon_img.attr('src', img != null ? img : weapon[front_weaponId]);

    if (front_weaponUpgrade != 0) {
        $('.weaponUpgrade_count').text(`+${front_weaponUpgrade/10}`);
    }

    // 색상 값을 변수로 선언
    let shadowColor = 'rgba(255, 255, 255, 0.7)';

    if (front_weaponUpgrade <= 10) shadowColor = 'rgba(255, 255, 255, 0.7)';
    else if (front_weaponUpgrade <= 20) shadowColor = 'rgba(150, 150, 150, 0.7)';
    else if (front_weaponUpgrade <= 30) shadowColor = 'rgba(163, 73, 164, 0.7)';
    else if (front_weaponUpgrade <= 40) shadowColor = 'rgba(63, 72, 204, 0.7)';
    else if (front_weaponUpgrade <= 50) shadowColor = 'rgba(0, 162, 232, 0.7)';
    else if (front_weaponUpgrade <= 60) shadowColor = 'rgba(34, 177, 76, 0.7)';
    else if (front_weaponUpgrade <= 70) shadowColor = 'rgba(224, 224, 64, 0.7)';
    else if (front_weaponUpgrade <= 80) shadowColor = 'rgba(255, 127, 39, 0.7)';
    else if (front_weaponUpgrade <= 90) shadowColor = 'rgba(224, 0, 64, 0.7)';

    if (front_weaponUpgrade > 0) {
        $weapon_img.css({
            'box-shadow': `0 0 1.5vh 0.5vh ${shadowColor}, inset 0 0 1.5vh 0.5vh ${shadowColor}`,
            'border-radius': '10vh 0 10vh 0'
        });
    }
}

//아이템 안내창 교체 버튼 눌렀을 떄
function Item_change() {
    // localStorage.setItem(nickname + 'weaponFind' + $randomWeapon, true);
    let changeImg = 0;

    if(characWeaponId === 1 && $randomWeapon === 1) {
        changeImg = weapon[0];
        front_weaponId = 0;
    } else {
        weaponFindUpdate(nickname, $randomWeapon);
        changeImg = weapon[$randomWeapon];
        front_weaponId = $randomWeapon;
    }

    // console.log('교체' + front_weaponId);
    weapon_img(changeImg);
    $item.fadeOut(1000).addClass('hidden');
    $item_text.fadeOut(1000).addClass('hidden');
}

//아이템 안내창 조합 버튼 눌렀을 떄
function Item_mix() {
    let changeNum = characWeaponId + ($randomWeapon % 10);
    if ($randomWeapon % 10 === 0) changeNum += 10;
    if (changeNum > 70) changeNum -= 10;
    // localStorage.setItem(nickname + 'weaponFind' + changeNum, true);
    weaponFindUpdate(nickname, changeNum);
    let changeImg = weapon[changeNum];
    front_weaponId = changeNum;
    // console.log('합성' + front_weaponId);
    weapon_img(changeImg);
    $item.fadeOut(1000).addClass('hidden');
    $item_text.fadeOut(1000).addClass('hidden');
}

// 아이템 안내창 강화 버튼 눌렀을 때
function Item_upgrade() {
    let rate = getRandom(1, 100);
    if (rate < 100 - upgradeNum) {
        front_weaponUpgrade += 10;
        upgradeNum += 10;
        $('.weaponUpgrade_count').text(`+${front_weaponUpgrade/10}`);
        show_alert("강화 성공! 무기가 한 단계 강화되었습니다. (" + rate + ")");
    } else if (rate < 100 - upgradeNum + 10) {
        front_weaponUpgrade -= 10;
        upgradeNum -= 10;
        $('.weaponUpgrade_count').text(`+${front_weaponUpgrade/10}`);
        show_alert("강화 실패! 무기가 한 단계 하락했습니다. (" + rate + ")");
    } else {
        show_alert("아무일도 일어나지 않았습니다. (" + rate + ")");
    }
    weapon_img();
    $item.fadeOut(1000).addClass('hidden');
    $item_text.fadeOut(1000).addClass('hidden');
}

//아이템 안내창 취소 버튼 눌렀을 떄
function Item_exit() {
    $item_text.fadeOut(1000).addClass('hidden');
    $random_item_text.fadeOut(1000).addClass('hidden');
}

function show_alert(message) {
    $alert_title.html(message);
    $alert.fadeIn(1000).removeClass('hidden');
}

function hide_alert() {
    $alert.fadeOut(1000).addClass('hidden');
}

//랜덤아이템 안내창 먹는다 버튼 눌렀을 떄
function Item_get() {
    let randomMax = characFloor * 50;
    if (randomMax > 2000) {
        randomMax = 2000;
    }
    let random_ability = getRandom(1, randomMax);
    let probability = 0;

    if (random_ability <= (probability += 200)) {
        updateStats('power', 'up', 1);
    } else if (random_ability <= (probability += 70)) {
        updateStats('power', 'up', 2);
    } else if (random_ability <= (probability += 50)) {
        updateStats('power', 'up', 3);
    } else if (random_ability <= (probability += 40)) {
        updateStats('power', 'up', 4);
    } else if (random_ability <= (probability += 35)) {
        updateStats('power', 'up', 5);
    } else if (random_ability <= (probability += 50)) {
        updateStats('speed', 'up', 10);
    } else if (random_ability <= (probability += 50)) {
        updateStats('speed', 'down', 10);
    } else if (random_ability <= (probability += 100)) {
        updateStats('power', 'down', 1);
    } else if (random_ability <= (probability += 70)) {
        updateStats('power', 'down', 2);
    } else if (random_ability <= (probability += 50)) {
        updateStats('power', 'down', 3);
    } else if (random_ability <= (probability += 40)) {
        updateStats('power', 'down', 4);
    } else if (random_ability <= (probability += 35)) {
        updateStats('power', 'down', 5);
    } else if (random_ability <= (probability += 25)) {
        updateStats('power', 'up', 6);
    } else if (random_ability <= (probability += 15)) {
        updateStats('power', 'up', 7);
    } else if (random_ability <= (probability += 10)) {
        updateStats('power', 'up', 8);
    } else if (random_ability <= (probability += 4)) {
        updateStats('power', 'up', 9);
    } else if (random_ability <= (probability += 1)) {
        updateStats('power', 'up', 10);
    } else if (random_ability <= (probability += 25)) {
        updateStats('power', 'down', 6);
    } else if (random_ability <= (probability += 15)) {
        updateStats('power', 'down', 7);
    } else if (random_ability <= (probability += 10)) {
        updateStats('power', 'down', 8);
    } else if (random_ability <= (probability += 4)) {
        updateStats('power', 'down', 9);
    } else if (random_ability <= (probability += 1)) {
        updateStats('power', 'down', 10);
    } else if (random_ability <= (probability += 30)) {
        updateStats('speed', 'up', 20);
    } else if (random_ability <= (probability += 30)) {
        updateStats('speed', 'down', 20);
    } else if (random_ability <= (probability += 15)) {
        updateStats('speed', 'up', 30);
    } else if (random_ability <= (probability += 15)) {
        updateStats('speed', 'down', 30);
    } else if (random_ability <= (probability += 4)) {
        updateStats('speed', 'up', 40);
    } else if (random_ability <= (probability += 4)) {
        updateStats('speed', 'down', 40);
    } else if (random_ability <= (probability += 1)) {
        updateStats('speed', 'up', 50);
    } else if (random_ability <= (probability + 1)) {
        updateStats('speed', 'down', 50);
    } else {
        show_alert('꽝');
    }
    $random_item.fadeOut(1000).addClass('hidden');
    $random_item_text.fadeOut(1000).addClass('hidden');
}

function updateStats(stats, action, number) {
    if (stats === 'power') {
        stats = '힘';
        if (action === 'up') {
            front_power += number;
            action = '+';
        } else if (action === 'down') {
            front_power -= number;
            action = '-';
        }
    } else if (stats === 'speed') {
        stats = '속도';
        if (action === 'up') {
            front_speed += number;
            action = '-';
        } else if (action === 'down') {
            front_speed -= number;
            action = '+';
        }
    }

    if (front_power < 0) front_power = 0;
    if (front_speed < 0) front_speed = 0;
    if (front_speed > 100) front_speed = 100;

    $power_count.text(front_power);
    $speed_count.text(50 - front_speed);

    show_alert(stats + action + number);
}

$(document).ready(function () {
    updateCharacterData(nickname);
});

let mobFind = 0;

// let mobFind = localStorage.getItem(nickname + 'MobFind') || 1;
(async () => {
    mobFind = Math.min(await getMobFind(nickname) || 0, mobs.length - 1);

    for (let i = 1; i <= mobFind; i++) {
        $(`.mobImage${i}`).attr('src', mobs[i]).addClass('cursor-help');
        $(`.mobName${i}`).text(mobNames[i]);

        let attackRange = '';
        if (i <= 10) attackRange = '없음';
        else if (i <= 20) attackRange = '몽둥이';
        else if (i <= 30) attackRange = '폭탄';
        else if (i <= 40) attackRange = '점액';
        else if (i <= 50) attackRange = '브레스';
        else if (i <= 54) attackRange = '분신';
        else attackRange = '랜덤';

        const currentCard = $('.mob__dictionary_card2').eq(i - 1);

        currentCard.append(`
            <div class="dictionary_body_text absolute">
                <div>${mobNames[i]}</div>
                데미지 ${i} <br> 체력 ${i * 10} <br> 무기 ${attackRange}
            </div>
        `);
    }
})();

/*for (i = 1; i <= 70; i++) {
    let weaponFind = localStorage.getItem(nickname + 'weaponFind' + i);
    if(weaponFind) $('.weaponImage' + i).attr('src', weapon[i])
}*/
/*
$.each(Object.keys(localStorage), function (_, key) {
    if (key.startsWith(`${nickname}weaponFind`)) {
        const index = key.replace(`${nickname}weaponFind`, ''); // 숫자 추출
        const indexNumber = parseInt(index, 10);

        if (weapon[indexNumber]) {
            $(`.weaponImage${indexNumber}`).attr('src', weapon[indexNumber]);
        }

        // 현재 순서에 해당하는 weapon__dictionary_card2 선택
        const currentCard = $('.weapon__dictionary_card2').eq(indexNumber - 1);

        currentCard.append(`
        <div class="dictionary_body_text absolute">
            <div>${weaponNames[indexNumber]}</div>
            데미지 ${Math.ceil(indexNumber / 10) * 10} <br>
            사거리 ${indexNumber % 10 === 0 ? 12 : (indexNumber % 10) + 2}
        </div>
        `);
    }
});
 */

// 인게임 헤드 js
let mob__itemsPerPage = 4; // 몬스터 도감 한 페이지에 보여줄 카드 개수
let mob__currentIndex = 0; // 몬스터 도감 현재 첫 번째로 보여지는 카드의 인덱스
let mob__totalItems = $('.mob__dictionary_card').length; // 몬스터 도감 총 몬스터 수
let mob__cardWidth = 20; // 몬스터 도감 카드의 너비(마진 포함)

let weapon__itemsPerPage = 4; // 무기 도감 한 페이지에 보여줄 카드 개수
let weapon__currentIndex = 0; // 무기 도감 현재 첫 번째로 보여지는 카드의 인덱스
let weapon__totalItems = $('.weapon__dictionary_card').length; // 무기 도감 총 무기 수
let weapon__cardWidth = 20; // 무기 도감 카드의 너비(마진 포함)

function mob__updateSlide() {
    // 이동할 위치 계산 (현재 인덱스에 맞게 이동)
    let mob__translateX = -mob__currentIndex * (mob__cardWidth + 3.5);
    $('.mob__dictionary_inner').css('transform', 'translateX(' + mob__translateX + 'vh)');
}

function mob__next() {
    if (mob__currentIndex + mob__itemsPerPage < mob__totalItems) {
        mob__currentIndex++;
    } else {
        mob__currentIndex = 0; // 마지막 카드에 도달하면 처음으로 돌아가기
    }
    mob__updateSlide();
}

function mob__prev() {
    if (mob__currentIndex > 0) {
        mob__currentIndex--;
    } else {
        mob__currentIndex = mob__totalItems - mob__itemsPerPage; // 처음으로 돌아가면 마지막 페이지로 이동
    }
    mob__updateSlide();
}

function weapon__updateSlide() {
    // 이동할 위치 계산 (현재 인덱스에 맞게 이동)
    let weapon__translateX = -weapon__currentIndex * (weapon__cardWidth + 3.5);
    // console.log("weapon__currentIndex : " + weapon__currentIndex);
    // console.log("weapon__itemsPerPage : " + weapon__itemsPerPage);
    // console.log("weapon__totalItems : " + weapon__totalItems);
    // console.log("weapon__cardWidth : " + weapon__cardWidth);
    // console.log("weapon__translateX : " + weapon__translateX);
    $('.weapon__dictionary_inner').css('transform', 'translateX(' + weapon__translateX + 'vh)');
}

function weapon__next() {
    if (weapon__currentIndex + weapon__itemsPerPage < weapon__totalItems) {
        weapon__currentIndex++;
    } else {
        weapon__currentIndex = 0; // 마지막 카드에 도달하면 처음으로 돌아가기
    }
    weapon__updateSlide();
}

function weapon__prev() {
    if (weapon__currentIndex > 0) {
        weapon__currentIndex--;
    } else {
        weapon__currentIndex = weapon__totalItems - weapon__itemsPerPage; // 처음으로 돌아가면 마지막 페이지로 이동
    }
    weapon__updateSlide();
}

// 몬스터 도감 버튼 클릭했을때 적용되는 함수
function showMob__dictionary() {
    $('.mob__dictionary').toggleClass('hidden');
    $('.mob__prev_bt').toggleClass('hidden');
    $('.mob__list_bt').toggleClass('hidden');
    $('.mob__next_bt').toggleClass('hidden');
    const $mob__dictionary_bt = $('.mob__dictionary_bt');
    $mob__dictionary_bt.toggleClass('play');
    $mob__dictionary_bt.toggleClass('pause');
}

function showWeapon__dictionary() {
    $('.weapon__dictionary').toggleClass('hidden');
    $('.weapon__prev_bt').toggleClass('hidden');
    $('.weapon__list_bt').toggleClass('hidden');
    $('.weapon__next_bt').toggleClass('hidden');
    const $weapon__dictionary_bt = $('.weapon__dictionary_bt');
    $weapon__dictionary_bt.toggleClass('play');
    $weapon__dictionary_bt.toggleClass('pause');
}

const bgTrackCount = 4;
const $audioPlayer = $('#audioPlayer');
const storageKey = 'audioPlaybackData';

function calculateBgTrackNumber(floor, room) {
    // console.log(floor + ',' + room);
    const roomOffset = (floor % 10 === 0 && room === 0) ? 0 : 1;
    return Math.floor((floor / 10) % bgTrackCount) + roomOffset;
}

function bgChange() {
    // console.log('previousTrackNumber : ' + previousTrackNumber);
    // console.log('currentTrackNumber : ' + currentTrackNumber);
    if (previousTrackNumber !== currentTrackNumber) {
        const bgAudioData = {
            currentTime: 0, // 타임을 0초로 리셋
            isPlaying: $audioPlayer[0].paused // 현재 재생 중인지 여부를 그대로 유지
        };
        localStorage.setItem(storageKey, JSON.stringify(bgAudioData));
    }
}

bgChange();

$(window).on('beforeunload', function () {
    const unloadAudioData = {
        currentTime: $audioPlayer[0].currentTime,
        isPlaying: !$audioPlayer[0].paused
    };
    localStorage.setItem(storageKey, JSON.stringify(unloadAudioData));
});
