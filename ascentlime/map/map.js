window.onerror = function () {
    window.location.href = 'https://eichi2514.github.io/ascentlime/restricted/restricted';
    return true;
};

const weapon = [
    'https://github.com/user-attachments/assets/3b0e2c34-227d-4135-91e3-b9cb0ff3207e',

    'https://github.com/user-attachments/assets/98a45b38-4cb3-4ee4-b8f7-28205ff39cb6',
    'https://github.com/user-attachments/assets/ca527de8-3ca6-44bb-9845-625e9f30ab89',
    'https://github.com/user-attachments/assets/91200c6c-bd4d-44eb-98df-96a7af967552',
    'https://github.com/user-attachments/assets/7403b724-19d1-49bf-9781-f97ac6936d68',
    'https://github.com/user-attachments/assets/eafa86a5-ff3c-4a3d-86e9-8f485c4905e1',
    'https://github.com/user-attachments/assets/fd1692a4-c906-4f24-b47d-1e2ac54fed56',
    'https://github.com/user-attachments/assets/f4621a93-e6db-4003-9e49-02fe7543491f',
    'https://github.com/user-attachments/assets/027a11ed-96fa-4587-9b7f-c3efde0e40b1',
    'https://github.com/user-attachments/assets/f531f906-2147-45b5-8af9-e0877201552c',
    'https://github.com/user-attachments/assets/dcc3fdaa-fa09-42a9-a929-3e7904925b41',

    'https://github.com/user-attachments/assets/330ad6aa-ead1-485b-900e-dea99d69abbc',
    'https://github.com/user-attachments/assets/4ba220d2-1c7f-4f84-bb1e-bc5eb8b4f531',
    'https://github.com/user-attachments/assets/791c3025-5ee3-4528-8cc2-8bbe8daf4bc0',
    'https://github.com/user-attachments/assets/1dd703a6-d7be-48ad-8eec-11960337c59c',
    'https://github.com/user-attachments/assets/87660691-5b05-427a-9471-94af0105d66d',
    'https://github.com/user-attachments/assets/c1776b21-dae8-4890-a91c-c93198a28d2a',
    'https://github.com/user-attachments/assets/03def50a-b4a8-4ccc-80de-e9f570d03dc5',
    'https://github.com/user-attachments/assets/2ac29faa-dba5-46b1-9a15-665ce62596ba',
    'https://github.com/user-attachments/assets/3e3ebf0f-e700-4a6f-91f5-ffbf9f16d69f',
    'https://github.com/user-attachments/assets/383a1c05-7a15-4974-8842-a4f0d3f3b747',

    'https://github.com/user-attachments/assets/34b8096b-643c-4323-adb9-384198f35a05',
    'https://github.com/user-attachments/assets/e745c414-919e-45a0-8ee8-b6708c677c97',
    'https://github.com/user-attachments/assets/98c2a891-0148-4b10-8ce8-1509fecdb511',
    'https://github.com/user-attachments/assets/417ceca3-7c5a-4b46-b7ba-597320a7280b',
    'https://github.com/user-attachments/assets/076ae1bc-5a66-4db3-be82-6f22e0b52155',
    'https://github.com/user-attachments/assets/c5b27034-7754-4a7c-b212-67bb919e60c1',
    'https://github.com/user-attachments/assets/6e8c1158-10dd-4769-8d3f-27d0df7e1ac6',
    'https://github.com/user-attachments/assets/7cd68d64-55c6-4da3-98d6-ec641e4d139b',
    'https://github.com/user-attachments/assets/7b8523d2-e443-44fc-9f79-dbebcf385b29',
    'https://github.com/user-attachments/assets/2ea0d667-6c8b-42c2-9eac-435e19422256',

    'https://github.com/user-attachments/assets/a114d57e-9995-4036-93be-e73087b93dee',
    'https://github.com/user-attachments/assets/fefa8e4d-6ce4-4258-9988-c6bee58defa6',
    'https://github.com/user-attachments/assets/44fc98a6-87f8-4444-b6af-6fb31c513ed9',
    'https://github.com/user-attachments/assets/2de1f608-83ba-42ad-b0b1-8ac51dea567a',
    'https://github.com/user-attachments/assets/a8369e91-a67f-44f0-9c4a-ef8fbb8cfe2a',
    'https://github.com/user-attachments/assets/388af076-05e8-452f-a501-a56f64c992c9',
    'https://github.com/user-attachments/assets/96270c25-7a7b-4086-ac06-5634555b70ef',
    'https://github.com/user-attachments/assets/89cf8667-6f45-440e-aa48-de352197809f',
    'https://github.com/user-attachments/assets/87a96719-bbac-410c-8a33-d7f67d39a2a2',
    'https://github.com/user-attachments/assets/4c81b6d8-1ab6-41e3-99e8-e289eb7510de',

    'https://github.com/user-attachments/assets/a08e3986-994d-4449-adb1-10e575714188',
    'https://github.com/user-attachments/assets/e8f0f8ed-0d14-4bed-8f14-d58a6ce6c537',
    'https://github.com/user-attachments/assets/5f99f1a8-cce0-43f4-9bd0-b01aff7ed337',
    'https://github.com/user-attachments/assets/b007b848-66f2-404f-9452-e4ca17e4ebf2',
    'https://github.com/user-attachments/assets/c6d3d271-dc7c-4cc1-908b-1960ece2ed80',
    'https://github.com/user-attachments/assets/157e3ef6-ca2b-47f8-96ba-4a4451534fec',
    'https://github.com/user-attachments/assets/40a08051-7223-4472-ab42-42bdbfeca35c',
    'https://github.com/user-attachments/assets/62dedd0e-9806-4fca-a7fb-d06fea28d1c4',
    'https://github.com/user-attachments/assets/d3e44839-8d46-4c0f-9e26-169bab080fdd',
    'https://github.com/user-attachments/assets/1afae587-dff3-42dd-a663-6730f5766187',

    'https://github.com/user-attachments/assets/2e6e4dc2-3b84-4521-b9c1-7eb469d8d861',
    'https://github.com/user-attachments/assets/44dc4242-4cc1-4bd9-bf1d-501625f79981',
    'https://github.com/user-attachments/assets/e0cd5573-f9ae-4a94-98b8-933b0317f6cd',
    'https://github.com/user-attachments/assets/221e2115-c9fe-4777-90de-b690b272268b',
    'https://github.com/user-attachments/assets/90731980-1fc7-49cb-8a99-f103082727ac',
    'https://github.com/user-attachments/assets/74c267ea-fa2f-494b-923e-fd8728e7346c',
    'https://github.com/user-attachments/assets/e3ac88c9-4c23-4f76-8a66-4780e32afcf7',
    'https://github.com/user-attachments/assets/47452f52-d6f9-4561-b984-59bf1abc6b0a',
    'https://github.com/user-attachments/assets/6435b887-2b87-4367-a088-28e13d0a9b59',
    'https://github.com/user-attachments/assets/fceed0f8-5b68-4263-b9f2-63d9dcb9eaa8',

    'https://github.com/user-attachments/assets/d3b5fb90-b21e-42a3-8964-a866132ace38',
    'https://github.com/user-attachments/assets/a75eb20d-7588-42c0-b517-c5cfa38293a1',
    'https://github.com/user-attachments/assets/bab07e9b-6bcc-4cc6-9782-d2e5491ed42e',
    'https://github.com/user-attachments/assets/351cb011-e0d8-4b97-ade0-e591aecd63f2',
    'https://github.com/user-attachments/assets/df28a7ef-027e-4b9c-9dfe-5333945f79b4',
    'https://github.com/user-attachments/assets/402dde9c-aeba-4543-a5a2-77d95ec25bba',
    'https://github.com/user-attachments/assets/c9258612-c30a-4e6b-8f43-d63518485e72',
    'https://github.com/user-attachments/assets/33899c93-1223-4e71-9113-7d7702c20b03',
    'https://github.com/user-attachments/assets/ead726f4-fa9f-4fd8-935a-0c665b173069',
    'https://github.com/user-attachments/assets/a6dcabfb-34c7-41bc-ad0e-94228de15519'
];

const mobs = [
    'https://github.com/user-attachments/assets/3b0e2c34-227d-4135-91e3-b9cb0ff3207e',
    'https://github.com/user-attachments/assets/2ab0ec46-1847-4c87-9b6c-b485ffd5bcc0',
    'https://github.com/user-attachments/assets/76d8bc9f-d814-4f60-b99f-e6688a60acd5',
    'https://github.com/user-attachments/assets/b7a6c561-9176-4f1e-98c5-0d6723bcca2b',
    'https://github.com/user-attachments/assets/49a90ef1-1246-4a74-933e-b78e180e2f30',
    'https://github.com/user-attachments/assets/34ce9a88-ab95-45a8-956b-a6c8ee129674',
    'https://github.com/user-attachments/assets/1314824d-d8a6-44f2-9672-ba5a0e7f3d6c',
    'https://github.com/user-attachments/assets/c5004b20-a313-41cd-b012-33c91f271664',
    'https://github.com/user-attachments/assets/d7afdd47-5dfe-4824-b456-841439908a6b',
    'https://github.com/user-attachments/assets/b39165ea-6d79-434c-a885-dc7aca00ac7a',
    'https://github.com/user-attachments/assets/11b950e4-9387-4547-8439-cc68568ee4d4',
    'https://github.com/user-attachments/assets/0814b836-a0a2-4a26-8f1e-caafee604a3b',
    'https://github.com/user-attachments/assets/30d1131c-5db0-4abb-97a1-b5bb9127f19d',
    'https://github.com/user-attachments/assets/b43717db-90e0-49cb-a80f-5d9144e8555d',
    'https://github.com/user-attachments/assets/6a623aaa-ebf6-4b76-b55b-cc4a80576060',
    'https://github.com/user-attachments/assets/7765f401-da7e-4d07-9ce2-a565e92a6651',
    'https://github.com/user-attachments/assets/80eb8427-67d6-41bb-831e-9fc95e0dc718',
    'https://github.com/user-attachments/assets/9c5464fa-5de4-475a-a601-8313e9d4070c',
    'https://github.com/user-attachments/assets/b86834e5-65d3-4e7a-91b0-96cf616dc0c1',
    'https://github.com/user-attachments/assets/24af62fa-4b25-4db8-83ca-edcd8b2a1cdd',
    'https://github.com/user-attachments/assets/1af80f91-f449-45f0-8553-0914dfa0e9a3',
    'https://github.com/user-attachments/assets/efc773bc-aa2d-4586-baa1-3cc313d2a059',
    'https://github.com/user-attachments/assets/05ca3139-c237-4110-86fa-ec1797db2d96',
    'https://github.com/user-attachments/assets/d120300e-a485-45b4-b4f0-e833092fe7a5',
    'https://github.com/user-attachments/assets/1c76742c-b8c8-4985-ac61-1ed71152ba6d',
    'https://github.com/user-attachments/assets/76d03e1c-9456-4edc-97be-2dbe41ef2ab0',
    'https://github.com/user-attachments/assets/5ee073e4-e111-4712-aea9-d07c4e00cf13',
    'https://github.com/user-attachments/assets/3760b544-5e2b-4c11-ac17-417c81dfe4f2',
    'https://github.com/user-attachments/assets/c711a2ae-ba08-431d-9695-bd198f19f0e0',
    'https://github.com/user-attachments/assets/064a8937-beb2-4dee-8ae5-ae4dd5fe6c24',
    'https://github.com/user-attachments/assets/136cda85-bf27-4d0d-8e79-5fbe36b7ac1f',
    'https://github.com/user-attachments/assets/cfbe7f09-078b-4056-82f9-2f70983d0f52',
    'https://github.com/user-attachments/assets/0bc0f092-e535-4c6d-8631-07c87e80014f',
    'https://github.com/user-attachments/assets/397fa4af-9a52-48d1-8bd0-629f575198c2',
    'https://github.com/user-attachments/assets/e426c503-1da8-4ad1-865a-a4fb6b9db70c',
    'https://github.com/user-attachments/assets/e815cb6a-6778-4110-9934-9a64f3174b98',
    'https://github.com/user-attachments/assets/75270bfd-b910-4e23-9e3a-b71af9cb0761',
    'https://github.com/user-attachments/assets/0df7b7a3-6625-4485-b3bc-646992ff0641',
    'https://github.com/user-attachments/assets/13d39b53-ee46-461d-a57d-06d54b5bb6f2',
    'https://github.com/user-attachments/assets/f6be058b-d91c-46a7-9eac-cf168701c133',
    'https://github.com/user-attachments/assets/fed7ffa9-3a4e-4aef-b6dd-40b715089f21',
    'https://github.com/user-attachments/assets/2672c70c-8d37-46de-acba-e9b1c2f4fbfc',
    'https://github.com/user-attachments/assets/1a25b242-de00-4b05-8bb8-47901f9e15b8',
    'https://github.com/user-attachments/assets/923bf658-6ded-439f-80a9-173689429f47',
    'https://github.com/user-attachments/assets/f7ac2d6e-1ae5-4b0e-988c-b1b7471f312a',
    'https://github.com/user-attachments/assets/50a96d00-65d3-422c-8ad0-01aef2c29ae7',
    'https://github.com/user-attachments/assets/648819e7-cbdb-43a3-a1dc-3bac31332dfc',
    'https://github.com/user-attachments/assets/e3d332b0-4a6c-473f-b6ac-0ade6db763aa',
    'https://github.com/user-attachments/assets/3aa893dd-fe2e-440c-a114-70d1290119f3',
    'https://github.com/user-attachments/assets/0c363b9c-6048-4e07-b304-d1a0283fb35b',
    'https://github.com/user-attachments/assets/66b9b527-566c-4a76-8a1b-3c7be2c695ef',
    'https://github.com/user-attachments/assets/b9dac1d9-afc9-4ce8-a6df-1c945dbc68db',
    'https://github.com/user-attachments/assets/53fd6e00-c519-41e2-adc1-3d848d34f3a7',
    'https://github.com/user-attachments/assets/1f52c6f6-40e8-48b6-907e-4e64b8907a27',
    'https://github.com/user-attachments/assets/25b5197e-0ab4-4fb5-9d11-644a7e46d954'
];

if (!localStorage.getItem('nickname')) {
    alert('잘못된 접근 방식입니다.');
    history.back();
}

const nickname = localStorage.getItem('nickname')
const characString = localStorage.getItem(nickname);  // 문자열로 가져옴
const charac = characString ? JSON.parse(characString) : {};  // JSON 파싱하여 객체로 변환

var front_hp = charac.hp;
var front_power = charac.power;
var front_speed = charac.speed;
var front_weaponId = charac.weaponId;
var front_weaponUpgrade = 0;

if (charac.weaponUpgrade != null) {
    front_weaponUpgrade = charac.weaponUpgrade
}

var upgradeNum = front_weaponUpgrade < 100 ? front_weaponUpgrade : 90;

if (charac.floor === 1 && charac.room === 0) $('.location').text('튜토리얼');
else if (charac.room !== 0) $('.location').text(charac.floor + '층 ' + charac.room + '번방');
else $('.location').text((charac.floor - 1) + '층 보스방');

const $hp_count = $('.hp_count');
$hp_count.text(front_hp);

const $power_count = $('.power_count');
$power_count.text(front_power);

const $speed_count = $('.speed_count');
$speed_count.text(50 - front_speed);

const $weapon_img = $('.weapon_img');

// 페이지가 시작될 때 시간 기록
const startTime = new Date().getTime();
var estimatedLoadTime = 1500; // 예상 로드 시간

// 페이지 로딩 중에 로딩 바가 점진적으로 증가하도록 설정
const interval = setInterval(function () {
    const currentTime = new Date().getTime();
    const elapsedTime = currentTime - startTime;

    // 경과된 시간에 비례해 로딩 바 너비 설정 (최대 80vh)
    const width = Math.min((elapsedTime / estimatedLoadTime) * 80, 80);
    $(".loding_bar").css("width", width + "vh");

    // 페이지가 로드되기 전에 80vh에 도달하지 않도록 안전하게 제한
    if (width >= 80) {
        clearInterval(interval); // 최대 너비에 도달하면 애니메이션 정지
    }
}, 100); // 100ms 마다 로딩 바 업데이트

// 윈도우 로딩 체크
var windowChack = false;

// window.onload 이벤트 감지
window.onload = function () {
    // console.clear();
    const loadTime = new Date().getTime() - startTime;

    if (charac.floor >= 0) {
        startTimer();
        updateTime();
    }

    // 실제 로드 시간이 예상 시간을 초과하지 않으면, 비율로 로딩 바 채우기
    const finalWidth = Math.min((loadTime / estimatedLoadTime) * 80, 80);
    $(".loding_bar").css("width", finalWidth + "vh");

    // 로딩 바가 완료된 후 로딩 화면 서서히 제거
    setTimeout(function () {
        $(".loding").fadeOut(500);
    }, 500);  // 로드가 완료되면 잠시 후 로딩 화면 제거

    setTimeout(function () {
        windowChack = true;
    }, 1000);
}

var seconds = charac.clearTime;

function updateTime() {
    const hrs = Math.floor(seconds / 3600);
    const mins = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;

    // 1초 단위로 형식화
    $(".time").text(
        hrs.toString().padStart(2, '0') + ":" +
        mins.toString().padStart(2, '0') + ":" +
        secs.toString().padStart(2, '0')
    );
}

function startTimer() {
    setInterval(() => {
        seconds++;
        updateTime();
    }, 1000);
}

// 랜덤 수 불러오는 함수 생성
function getRandom(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

const $item = charac.weaponId < 70 ? $(".item1") : $(".item2");
const $item_text = charac.weaponId < 70 ? $(".item_text1") : $(".item_text2");
const $random_item = $(".random_item");
const $random_item_text = $(".random_item_text");

var weaponMax = (charac.floor - 1) * 10;
if (weaponMax > 70) weaponMax = 70;
var $randomWeapon = getRandom(1, weaponMax);

var randomItem = getRandom(1, 3);

if (randomItem === 3) $('.random_item_effect').removeClass('hidden');

function weapon_img(img) {
    $weapon_img.attr('src', img != null ? img : weapon[front_weaponId]);
    // 색상 값을 변수로 선언
    var shadowColor = 'rgba(255, 255, 255, 0.7)';

    if (upgradeNum <= 10) shadowColor = 'rgba(255, 255, 255, 0.7)';
    else if (upgradeNum <= 20) shadowColor = 'rgba(150, 150, 150, 0.7)';
    else if (upgradeNum <= 30) shadowColor = 'rgba(163, 73, 164, 0.7)';
    else if (upgradeNum <= 40) shadowColor = 'rgba(63, 72, 204, 0.7)';
    else if (upgradeNum <= 50) shadowColor = 'rgba(0, 162, 232, 0.7)';
    else if (upgradeNum <= 60) shadowColor = 'rgba(34, 177, 76, 0.7)';
    else if (upgradeNum <= 70) shadowColor = 'rgba(224, 224, 64, 0.7)';
    else if (upgradeNum <= 80) shadowColor = 'rgba(255, 127, 39, 0.7)';
    else if (upgradeNum <= 90) shadowColor = 'rgba(224, 0, 64, 0.7)';

    if (upgradeNum > 0) {
        $weapon_img.css({
            'box-shadow': `0 0 1.5vh 0.5vh ${shadowColor}, inset 0 0 1.5vh 0.5vh ${shadowColor}`,
            'border-radius': '10vh 0 10vh 0'
        });
    }
}

//아이템 안내창 교체 버튼 눌렀을 떄
function Item_change() {
    localStorage.setItem(nickname + 'weaponFind' + $randomWeapon, true);
    let changeImg = weapon[$randomWeapon];
    front_weaponId = $randomWeapon;
    // console.log('교체' + front_weaponId);
    weapon_img(changeImg);
    $item.fadeOut(1000).addClass('hidden');
    $item_text.fadeOut(1000).addClass('hidden');
}

//아이템 안내창 조합 버튼 눌렀을 떄
function Item_mix() {
    let changeNum = charac.weaponId + ($randomWeapon % 10);
    if ($randomWeapon % 10 === 0) changeNum += 10;
    if (changeNum > 70) changeNum -= 10;
    localStorage.setItem(nickname + 'weaponFind' + changeNum, true);
    let changeImg = weapon[changeNum];
    front_weaponId = changeNum;
    // console.log('합성' + front_weaponId);
    weapon_img(changeImg);
    $item.fadeOut(1000).addClass('hidden');
    $item_text.fadeOut(1000).addClass('hidden');
}

// 아이템 안내창 강화 버튼 눌렀을 때
function Item_upgrade() {
    let rate = getRandom(1, 100);
    if (rate < 100 - upgradeNum) {
        front_weaponUpgrade += 10;
        upgradeNum += 10;
        alert("강화 성공! 무기가 한 단계 강화되었습니다. (" + rate + ")");
    } else if (rate < 100 - upgradeNum + 10) {
        front_weaponUpgrade -= 10;
        upgradeNum -= 10;
        alert("강화 실패! 무기가 한 단계 하락했습니다. (" + rate + ")");
    } else {
        alert("아무일도 일어나지 않았습니다. (" + rate + ")");
    }
    weapon_img();
    $item.fadeOut(1000).addClass('hidden');
    $item_text.fadeOut(1000).addClass('hidden');
}


//아이템 안내창 취소 버튼 눌렀을 떄
function Item_exit() {
    $item_text.fadeOut(1000).addClass('hidden');
    $random_item_text.fadeOut(1000).addClass('hidden');
}

//랜덤아이템 안내창 먹는다 버튼 눌렀을 떄
function Item_get() {
    let randomMax = charac.floor * 50;
    if (randomMax > 2000) {
        randomMax = 2000;
    }
    let random_ability = getRandom(1, randomMax);
    let probability = 0;

    if (random_ability <= (probability += 200)) {
        updateStats('power', 'up', 1);
    } else if (random_ability <= (probability += 70)) {
        updateStats('power', 'up', 2);
    } else if (random_ability <= (probability += 50)) {
        updateStats('power', 'up', 3);
    } else if (random_ability <= (probability += 40)) {
        updateStats('power', 'up', 4);
    } else if (random_ability <= (probability += 35)) {
        updateStats('power', 'up', 5);
    } else if (random_ability <= (probability += 50)) {
        updateStats('speed', 'up', 10);
    } else if (random_ability <= (probability += 50)) {
        updateStats('speed', 'down', 10);
    } else if (random_ability <= (probability += 100)) {
        updateStats('power', 'down', 1);
    } else if (random_ability <= (probability += 70)) {
        updateStats('power', 'down', 2);
    } else if (random_ability <= (probability += 50)) {
        updateStats('power', 'down', 3);
    } else if (random_ability <= (probability += 40)) {
        updateStats('power', 'down', 4);
    } else if (random_ability <= (probability += 35)) {
        updateStats('power', 'down', 5);
    } else if (random_ability <= (probability += 25)) {
        updateStats('power', 'up', 6);
    } else if (random_ability <= (probability += 15)) {
        updateStats('power', 'up', 7);
    } else if (random_ability <= (probability += 10)) {
        updateStats('power', 'up', 8);
    } else if (random_ability <= (probability += 4)) {
        updateStats('power', 'up', 9);
    } else if (random_ability <= (probability += 1)) {
        updateStats('power', 'up', 10);
    } else if (random_ability <= (probability += 25)) {
        updateStats('power', 'down', 6);
    } else if (random_ability <= (probability += 15)) {
        updateStats('power', 'down', 7);
    } else if (random_ability <= (probability += 10)) {
        updateStats('power', 'down', 8);
    } else if (random_ability <= (probability += 4)) {
        updateStats('power', 'down', 9);
    } else if (random_ability <= (probability += 1)) {
        updateStats('power', 'down', 10);
    } else if (random_ability <= (probability += 30)) {
        updateStats('speed', 'up', 20);
    } else if (random_ability <= (probability += 30)) {
        updateStats('speed', 'down', 20);
    } else if (random_ability <= (probability += 15)) {
        updateStats('speed', 'up', 30);
    } else if (random_ability <= (probability += 15)) {
        updateStats('speed', 'down', 30);
    } else if (random_ability <= (probability += 4)) {
        updateStats('speed', 'up', 40);
    } else if (random_ability <= (probability += 4)) {
        updateStats('speed', 'down', 40);
    } else if (random_ability <= (probability += 1)) {
        updateStats('speed', 'up', 50);
    } else if (random_ability <= (probability + 1)) {
        updateStats('speed', 'down', 50);
    } else {
        alert('꽝');
    }
    $random_item.fadeOut(1000).addClass('hidden');
    $random_item_text.fadeOut(1000).addClass('hidden');
}

function updateStats(stats, action, number) {
    if (stats === 'power') {
        stats = '힘';
        if (action === 'up') {
            front_power += number;
            action = '+';
        } else if (action === 'down') {
            front_power -= number;
            action = '-';
        }
    } else if (stats === 'speed') {
        stats = '속도';
        if (action === 'up') {
            front_speed += number;
            action = '-';
        } else if (action === 'down') {
            front_speed -= number;
            action = '+';
        }
    }

    if (front_power < 0) front_power = 0;
    if (front_speed < 0) front_speed = 0;
    if (front_speed > 100) front_speed = 100;

    $power_count.text(front_power);
    $speed_count.text(50 - front_speed);

    alert(stats + action + number);
}

$(document).ready(function () {
    var $mob_index = charac.floor;

    if ($mob_index > 53) {
        $mob_index = getRandom(1, 53);
    }

    // $('.attackSize').attr('src', weapon[front_weaponId]);
    if (charac.weaponId < 70) $item.attr('src', weapon[$randomWeapon]);

    weapon_img();

    $(".rate").text(100 - upgradeNum);

    if (charac.room === 0) $('.mob_img').attr('src', mobs[$mob_index - 1]);
    else $('.mob_img').attr('src', mobs[$mob_index]);

    var damage = ((Math.floor(front_weaponId / 10)) * 10) + front_power + front_weaponUpgrade;
    if ((front_weaponId % 10) !== 0) {
        damage += 10;
    }

    // 캐릭터 위치 변수
    var LR = 10;
    var UD = 44;

    // 몬스터 좌표 셋팅
    var UD2 = getRandom(10, 70);
    if (UD2 % 2 !== 0) UD2++;
    var LR2 = getRandom(30, 70);
    if (LR2 % 2 !== 0) LR2++;

    var UD3 = getRandom(10, 70);
    if (UD3 % 2 !== 0) UD3++;
    var LR3 = getRandom(30, 70);
    if (LR3 % 2 !== 0) LR3++;

    var UD4 = getRandom(10, 70);
    if (UD4 % 2 !== 0) UD4++;
    var LR4 = getRandom(30, 70);
    if (LR4 % 2 !== 0) LR4++;

    var UD5 = getRandom(10, 70);
    if (UD5 % 2 !== 0) UD5++;
    var LR5 = getRandom(30, 70);
    if (LR5 % 2 !== 0) LR5++;

    var UD6 = getRandom(10, 40);
    if (UD6 % 2 !== 0) UD6++;
    var LR6 = getRandom(30, 40);
    if (LR6 % 2 !== 0) LR6++;

    var mobDamage = charac.floor;
    if (charac.room === 0) {
        mobDamage--;
    }

    // 알림창을 표시
    if (charac.floor === 1 && charac.room === 0) {
        let $tutorialContainer = $("#tutorialContainer");
        // guide1 추가
        $tutorialContainer.append('<div class="guide1 bg-black text-gray-400 text-center absolute">A W D S : 공격</div>');
        // guide2 추가
        $tutorialContainer.append('<div class="guide2 bg-black text-gray-400 text-center absolute">← ↑ → ↓ : 이동</div>');
    }

    const $mob2 = $(".mob2");
    const $mob3 = $(".mob3");
    const $mob4 = $(".mob4");
    const $mob5 = $(".mob5");
    const $mob6 = $(".mob6");

    $mob2.css("top", UD2 + "vh");
    $mob3.css("top", UD3 + "vh");
    $mob4.css("top", UD4 + "vh");
    $mob5.css("top", UD5 + "vh");
    $mob6.css("top", UD6 + "vh");

    $mob2.css("left", LR2 + "vh");
    $mob3.css("left", LR3 + "vh");
    $mob4.css("left", LR4 + "vh");
    $mob5.css("left", LR5 + "vh");
    $mob6.css("left", LR6 + "vh");

    var moveInterval; // 캐릭터 이동을 위한 interval
    var moveActionChack = null; // 현재 움직이고 있는 방향 추적

    function startMoving(moveAction) {
        // 이미 해당 방향으로 움직이고 있으면 중복 방지
        if (moveActionChack === moveAction) return;

        // 새로운 방향으로 이동 시작
        stopMoving(); // 이전 움직임을 중지하고 새로운 움직임 시작
        moveActionChack = moveAction;

        moveInterval = setInterval(function () {
            moveCharacter(moveAction, 1)
        }, front_speed);
    }

    function stopMoving() {
        if (moveInterval) {
            clearInterval(moveInterval); // 이전 움직임 중지
            moveInterval = null; // interval 초기화
        }
        moveActionChack = null; // 현재 방향 초기화
    }

    let lastKeyDirection = null; // 마지막으로 처리된 키 방향

    $(window).keydown(function (e) {
        const $characImg = $('.front_charac_img');
        const chatInputFocused = $('input[name="body"]').is(':focus');  // 채팅 입력창에 포커스가 있는지 확인

        // 채팅창이 포커스 상태일 때는 키보드 이벤트를 무시
        if (chatInputFocused || !windowChack) {
            return;  // 채팅창에 포커스가 있으면 함수 종료 (키 이벤트 무시)
        }

        const keyMap = {
            37: {direction: 'left', scale: -1},
            38: {direction: 'up'},
            39: {direction: 'right', scale: 1},
            40: {direction: 'down'}
        };

        const keyAction = keyMap[e.keyCode];
        if (keyAction && moveActionChack !== keyAction.direction) {
            // 중복된 키 입력 방지
            if (lastKeyDirection === keyAction.direction) return;
            lastKeyDirection = keyAction.direction;

            // 방향에 따라 이미지 반전
            if (keyAction.scale !== undefined) {
                $characImg.css('transform', `scaleX(${keyAction.scale})`);
            }

            // 애니메이션 유지
            $characImg.css('animation', 'move_action' + keyAction.scale + ' 1s linear infinite');

            // 이동 시작
            startMoving(keyAction.direction);
        }

        if (e.keyCode === 13) {
            // 랜덤 아이템 안내창이 보여지는중인지 확인
            const isRandomItemHidden = $('.random_item_text').hasClass('hidden');
            const isItemHidden1 = $('.item_text1').hasClass('hidden');
            const isItemHidden2 = $('.item_text2').hasClass('hidden');

            console.log(isItemHidden1 + ', ' + isItemHidden2 + ', ' + charac.floor + ', ' + charac.room + ', ' + charac.weaponId);

            // 입력 필드가 포커스되어 있을 때만 전송 처리
            if ($('.chat_var').is(':focus')) {
                e.preventDefault(); // 엔터로 인한 기본 동작(폼 제출 방지)을 막음
                $(e.target).closest('form').submit();  // 현재 입력 필드와 연결된 폼만 제출
            } else if (!isRandomItemHidden && randomItem === 3) {
                Item_get();
            } else if (!isItemHidden1 && charac.floor !== 1 && charac.room === 0 && charac.weaponId < 70) {
                Item_mix();
            } else if (!isItemHidden2 && charac.floor !== 1 && charac.room === 0 && charac.weaponId >= 70) {
                Item_upgrade();
            }
        }
    });

    // 키에서 손을 뗄 때 움직임 멈춤
    $(window).keyup(function (e) {
        const $characImg = $('.front_charac_img');
        const chatInputFocused = $('input[name="body"]').is(':focus');  // 채팅 입력창에 포커스가 있는지 확인

        // 채팅창이 포커스 상태일 때는 키보드 이벤트를 무시
        if (chatInputFocused) {
            return;  // 채팅창에 포커스가 있으면 함수 종료 (키 이벤트 무시)
        }

        // 눌렀던 방향키에서 손을 뗐을 때 이동 중지
        if ((e.keyCode === 37 && moveActionChack === 'left') ||
            (e.keyCode === 38 && moveActionChack === 'up') ||
            (e.keyCode === 39 && moveActionChack === 'right') ||
            (e.keyCode === 40 && moveActionChack === 'down')) {
            lastKeyDirection = null; // 키 입력 상태 초기화
            $characImg.css('animation', 'none');
            stopMoving();
        }

        if (e.keyCode === 65) {
            $characImg.css("transform", "scaleX(-1)");
            attack('A', 1);
        } else if (e.keyCode === 87) {
            attack('W', 1);
        } else if (e.keyCode === 68) {
            $characImg.css("transform", "scaleX(1)");
            attack('D', 1);
        } else if (e.keyCode === 83) {
            attack('S', 1);
        }
    });


    const $touch_left = $('.key-left');
    const $touch_up = $('.key-up');
    const $touch_right = $('.key-right');
    const $touch_down = $('.key-down');
    const $characImg = $('.front_charac_img');

    const handleTouchStart = (direction, scale) => {
        if (moveActionChack === direction) return;
        lastKeyDirection = direction;

        if (scale !== undefined) {
            $characImg.css('transform', `scaleX(${scale})`);
        }
        $characImg.css('animation', 'move_action' + scale + ' 1s linear infinite');
        startMoving(direction);
    };

    const handleTouchEnd = (direction) => {
        if (moveActionChack === direction) {
            lastKeyDirection = null;
            $characImg.css('animation', 'none');
            stopMoving();
        }
    };

    $touch_left.on("touchstart", () => {
        handleTouchStart('left', -1)
    });

    $touch_up.on("touchstart", () => {
        handleTouchStart('up')
    });

    $touch_right.on("touchstart", () => {
        handleTouchStart('right', 1)
    });

    $touch_down.on("touchstart", () => {
        handleTouchStart('down')
    });

    $touch_left.on("touchend", () => {
        handleTouchEnd('left')
    });

    $touch_up.on("touchend", () => {
        handleTouchEnd('up')
    });

    $touch_right.on("touchend", () => {
        handleTouchEnd('right')
    });

    $touch_down.on("touchend", () => {
        handleTouchEnd('down')
    });

    const $touch_Aattack = $('.key-Aattack');
    const $touch_Wattack = $('.key-Wattack');
    const $touch_Dattack = $('.key-Dattack');
    const $touch_Sattack = $('.key-Sattack');

    $touch_Aattack.on("touchstart", () => {
        $characImg.css("transform", "scaleX(-1)");
        attack('A', 1);
    });

    $touch_Wattack.on("touchstart", () => {
        attack('W', 1)
    });

    $touch_Dattack.on("touchstart", () => {
        $characImg.css("transform", "scaleX(1)");
        attack('D', 1);
    });

    $touch_Sattack.on("touchstart", () => {
        attack('S', 1)
    });

    function moveCharacter(moveAction, something) {
        // console.log("moveAction :" + moveAction + ", mob : " + "mob" + something);

        if (!windowChack) return;

        let data = moveChack(moveAction, something);


        // console.log('moveAction : ' + moveAction + ' / something : ' + something + ' / data : ' + data);

        if (something !== 1 && data === 1) {
            hpDown(mobDamage);
            damage__motion('1', mobDamage);
        } else if (something === 1 && data > 1) {
            hpDown(mobDamage);
            damage__motion('1', mobDamage);
        }

        if (something === 1) {
            if (moveAction === 'up' && UD > 10) {
                UD -= 2;
                $(".charac").css("top", UD + "vh");
            } else if (moveAction === 'down' && UD < 80) {
                UD += 2;
                $(".charac").css("top", UD + "vh");
            } else if (moveAction === 'left' && LR > 10) {
                LR -= 2;
                $(".charac").css("left", LR + "vh");
            } else if (moveAction === 'right' && LR < 80) {
                LR += 2;
                $(".charac").css("left", LR + "vh");
            }

            // console.log("UD :" + UD + ", LR : " + LR);
            showDoor();
            stageUp();
            showItem_text();
            showRandomItem_text();
        } else if (something === 2) {
            if (moveAction === 'up' && UD2 > 10) {
                UD2 -= 2;
                $(".mob" + something).css("top", UD2 + "vh");
            } else if (moveAction === 'down' && UD2 < 80) {
                UD2 += 2;
                $(".mob" + something).css("top", UD2 + "vh");
            } else if (moveAction === 'left' && LR2 > 10) {
                LR2 -= 2;
                $(".mob" + something).css("left", LR2 + "vh");
            } else if (moveAction === 'right' && LR2 < 80) {
                LR2 += 2;
                $(".mob" + something).css("left", LR2 + "vh");
            }
        } else if (something === 3) {
            if (moveAction === 'up' && UD3 > 10) {
                UD3 -= 2;
                $(".mob" + something).css("top", UD3 + "vh");
            } else if (moveAction === 'down' && UD3 < 80) {
                UD3 += 2;
                $(".mob" + something).css("top", UD3 + "vh");
            } else if (moveAction === 'left' && LR3 > 10) {
                LR3 -= 2;
                $(".mob" + something).css("left", LR3 + "vh");
            } else if (moveAction === 'right' && LR3 < 80) {
                LR3 += 2;
                $(".mob" + something).css("left", LR3 + "vh");
            }
        } else if (something === 4) {
            if (moveAction === 'up' && UD4 > 10) {
                UD4 -= 2;
                $(".mob" + something).css("top", UD4 + "vh");
            } else if (moveAction === 'down' && UD4 < 80) {
                UD4 += 2;
                $(".mob" + something).css("top", UD4 + "vh");
            } else if (moveAction === 'left' && LR4 > 10) {
                LR4 -= 2;
                $(".mob" + something).css("left", LR4 + "vh");
            } else if (moveAction === 'right' && LR4 < 80) {
                LR4 += 2;
                $(".mob" + something).css("left", LR4 + "vh");
            }
        } else if (something === 5) {
            if (moveAction === 'up' && UD5 > 10) {
                UD5 -= 2;
                $(".mob" + something).css("top", UD5 + "vh");
            } else if (moveAction === 'down' && UD5 < 80) {
                UD5 += 2;
                $(".mob" + something).css("top", UD5 + "vh");
            } else if (moveAction === 'left' && LR5 > 10) {
                LR5 -= 2;
                $(".mob" + something).css("left", LR5 + "vh");
            } else if (moveAction === 'right' && LR5 < 80) {
                LR5 += 2;
                $(".mob" + something).css("left", LR5 + "vh");
            }
        } else if (something === 6) {
            if (moveAction === 'up' && UD6 > 10) {
                UD6 -= 2;
                $(".mob" + something).css("top", UD6 + "vh");
            } else if (moveAction === 'down' && UD6 < 70) {
                UD6 += 2;
                $(".mob" + something).css("top", UD6 + "vh");
            } else if (moveAction === 'left' && LR6 > 10) {
                LR6 -= 2;
                $(".mob" + something).css("left", LR6 + "vh");
            } else if (moveAction === 'right' && LR6 < 70) {
                LR6 += 2;
                $(".mob" + something).css("left", LR6 + "vh");
            }
        }
    }

    function attack(direction, something) {

        if (!windowChack) return;

        // 먼저 attack_motion 을 즉시 실행
        attack_motion(something, direction);

        // 나머지 로직은 0.5초 뒤에 실행
        // setTimeout(() => {
        let data = attackChack(something, direction);
        // console.log(data);
        if (something !== 1 && data === 1) {
            if (something < 6) {
                hpDown(mobDamage);
                damage__motion('1', mobDamage);
            } else {
                hpDown(mobDamage * 2);
                damage__motion('1', mobDamage * 2);
            }
        } else if (something === 1 && data === 2) {
            mob2_hp -= damage;
            damage__motion(data, damage);
            if (mob2_hp <= 0) {
                mobHidden(2);
                clearInterval(stop2);
            }
        } else if (something === 1 && data === 3) {
            mob3_hp -= damage;
            damage__motion(data, damage);
            if (mob3_hp <= 0) {
                mobHidden(3);
                clearInterval(stop3);
            }
        } else if (something === 1 && data === 4) {
            mob4_hp -= damage;
            damage__motion(data, damage);
            if (mob4_hp <= 0) {
                mobHidden(4);
                clearInterval(stop4);
            }
        } else if (something === 1 && data === 5) {
            mob5_hp -= damage;
            damage__motion(data, damage);
            if (mob5_hp <= 0) {
                mobHidden(5);
                clearInterval(stop5);
            }
        } else if (something === 1 && data === 6) {
            mob6_hp -= damage;
            damage__motion(data, damage);
            if (mob6_hp <= 0) {
                mobHidden(6);
                clearInterval(stop6);
                showItem();
            }
            BossHpDown();
        }
        if (something === 1) {
            showDoor();
            showRandomItem();
        }
        // }, 400);
    }

    let saveCooldown = false; // 저장 쿨타임 변수

    async function saveLog() {
        if (saveCooldown) return; // 쿨타임 중이면 저장하지 않음

        saveCooldown = true;  // 저장 시작

        try {
            await saveFirebaseLogs(charac, seconds); // 비동기 작업 완료될 때까지 기다림
            localStorage.setItem(nickname + 'playCount', (parseInt(localStorage.getItem(nickname + 'playCount')) || 0) + 1);
        } catch (error) {
            console.error("로그 저장 중 오류 발생:", error);
        } finally {
            saveCooldown = false; // 작업이 끝나면 쿨타임 해제
            location.href = '../over';
        }
    }

    // hp 감소
    async function hpDown(mobDamage) {
        front_hp -= mobDamage;
        $('.hp_count').text(front_hp);
        characHpDown();
        if (front_hp <= 0) {
            /* localStorage.setItem(nickname, nickname + "/1/0/100/0/50/1/0"); */
            localStorage.setItem(nickname, JSON.stringify({
                name: nickname,
                floor: 1,
                room: 0,
                hp: 100,
                power: 0,
                speed: 50,
                weaponId: 1,
                weaponUpgrade: 0,
                clearTime: 0
            }));
            await saveLog();
        }
    }

    // 캐릭 체력바 변화 함수
    function characHpDown() {
        let new_characHp_width = (8 / 10) * (front_hp % 10);
        // console.log(new_characHp_width);
        let characHp_number = Math.floor(front_hp / 10);
        if (front_hp % 10 === 0) {
            new_characHp_width = 8;
            characHp_number--;
        }
        // console.log("체력 넓이 : " + new_characHp_width + ", 줄 수 : " + characHp_number);
        for (let i = characHp_number - 1; i >= 0; i--) {
            $(".characHP_bar" + i).css('width', '8vh');
        }
        for (let i = characHp_number + 1; i < 11; i++) {
            $(".characHP_bar" + i).css('width', '0vh');
        }

        // console.log(".characHP_bar"+(characHp_number-1));
        $(".characHP_bar" + characHp_number).css('width', new_characHp_width + 'vh');
        $(".characHP_bar_text").text('x' + (characHp_number + 1));
    }

    //몬스터 사라지게하는 함수
    function mobHidden(num) {
        $(".mob" + num).fadeOut(2000, function () {
            $(this).addClass('hidden');
        });
    }

    function moveChack(moveAction, something) {
        let Xcode = somethingXcode(something) - 5;
        let Ycode = somethingYcode(something) - 5;
        let height = something > 5 ? 10 : 5;
        let width = something > 5 ? 10 : 5;

        // 맵 생성
        const map2 = mapChack(something);

        // for (i = 0; i < 40; i++) {
        //    let log = '';
        //    for (j = 0; j < 40; j++) {
        //        log += '[' + map2[i][j] + ']';
        //    }
        //    console.log(log);
        //}

        // something 주위 공간 확인
        if (moveAction === 'up') {
            for (let y = Ycode; y < Ycode + width && y < 40; y++) {
                if (Xcode - 1 >= 0 && map2[Xcode - 1][y] !== 0) {
                    return map2[Xcode - 1][y];
                }
            }
        } else if (moveAction === 'down') {
            for (let y = Ycode; y < Ycode + width && y < 40; y++) {
                if (Xcode + height < 40 && map2[Xcode + height][y] !== 0) {
                    return map2[Xcode + height][y];
                }
            }
        } else if (moveAction === 'left') {
            for (let x = Xcode; x < Xcode + height && x < 40; x++) {
                if (Ycode - 1 >= 0 && map2[x][Ycode - 1] !== 0) {
                    return map2[x][Ycode - 1];
                }
            }
        } else if (moveAction === 'right') {
            for (let x = Xcode; x < Xcode + height && x < 40; x++) {
                if (Ycode + width < 40 && map2[x][Ycode + width] !== 0) {
                    return map2[x][Ycode + width];
                }
            }
        }

        return 0;
    }

    // 공격 대상 확인 함수
    function attackChack(something, direction) {
        let Xcode = somethingXcode(something) - 5;
        let Ycode = somethingYcode(something) - 5;
        let height = something > 5 ? 8 : 4;
        let width = something > 5 ? 8 : 4;

        // console.log('Xcode : ' + Xcode);
        // console.log('Ycode : ' + Ycode);

        let distance = somethingDistance(something, front_weaponId, charac.floor);

        // console.log('something : ' + something);

        // 맵 생성
        const map3 = mapChack(something);

        if (direction === 'A') {
            let x = Xcode + (height / 2);
            let y = Ycode - distance;
            // console.log('x : ' + x);
            // console.log('y : ' + y);

            for (let i = Ycode - 1; i > y && i >= 0; i--) {
                if (map3[x][i] !== 0) {
                    return map3[x][i];
                }
            }
        } else if (direction === 'W') {
            let x = Xcode - distance;
            let y = Ycode + (width / 2);
            // console.log('x : ' + x);
            // console.log('y : ' + y);

            for (let i = Xcode - 1; i > x && i >= 0; i--) {
                if (map3[i][y] !== 0) {
                    return map3[i][y];
                }
            }
        } else if (direction === 'D') {
            let x = Xcode + (height / 2);
            let y = Ycode + width + distance;
            // console.log('x : ' + x);
            // console.log('y : ' + y);

            for (let i = Ycode + width; i < y && i < 40; i++) {
                if (map3[x][i] !== 0) {
                    return map3[x][i];
                }
            }
        } else if (direction === 'S') {
            let x = Xcode + height + distance;
            let y = Ycode + (width / 2);
            // console.log('x : ' + x);
            // console.log('y : ' + y);

            for (let i = Xcode + height; i < x && i < 40; i++) {
                if (map3[i][y] !== 0) {
                    return map3[i][y];
                }
            }
        }
        return 0;
    }

    // 아이템 안내창 공개
    function showItem_text() {
        let itemChack = $item.hasClass('hidden');
        // console.log("아이템 공개 여부"+itemChack);
        if (LR > 64 && LR < 76 && UD < 56 && UD > 34 && !itemChack && charac.floor > 1 && charac.room === 0) {
            $item_text.fadeIn(1000).removeClass('hidden');
        }
    }

    // 아이템 공개
    function showItem() {
        $item.fadeIn(1000).removeClass('hidden');
    }

    // 랜덤아이템 안내창 공개
    function showRandomItem_text() {
        let randomItemChack = $(".random_item").hasClass('hidden');
        // console.log("아이템 공개 여부"+itemChack);
        if (UD > 64 && UD < 76 && LR < 56 && LR > 34 && !randomItemChack) {
            $(".random_item_text").fadeIn(1000).removeClass('hidden');
        }
    }

    var isItem = true;

    function showRandomItem() {
        const isSpecialRoom = (charac.floor === 8 && charac.room === 0);
        const allMobsDefeated = (mob2_hp <= 0 && mob3_hp <= 0 && mob4_hp <= 0 && mob5_hp <= 0 && mob6_hp <= 0);
        const isSpecialItem = (randomItem === 3);
        const isExcludedRoom = (charac.floor === 1 && charac.room === 0);

        if (!isExcludedRoom && allMobsDefeated && isSpecialItem && (isSpecialRoom || isItem)) {
            isItem = false;
            $(".random_item").fadeIn(1000).removeClass('hidden');
        }
    }

    function somethingXcode(something) {
        if (something === 1) return UD / 2;
        else if (something === 2) return UD2 / 2;
        else if (something === 3) return UD3 / 2;
        else if (something === 4) return UD4 / 2;
        else if (something === 5) return UD5 / 2;
        else if (something === 6) return UD6 / 2;
        return 0;
    }

    function somethingYcode(something) {
        if (something === 1) return LR / 2;
        else if (something === 2) return LR2 / 2;
        else if (something === 3) return LR3 / 2;
        else if (something === 4) return LR4 / 2;
        else if (something === 5) return LR5 / 2;
        else if (something === 6) return LR6 / 2;
        return 0;
    }

    function mapChack(something) {
        let characXCode = (UD / 2) - 5;
        let characYCode = (LR / 2) - 5;
        let mob2XCode = (UD2 / 2) - 5;
        let mob2YCode = (LR2 / 2) - 5;
        let mob2life = mob2_hp > 0;
        let mob3XCode = (UD3 / 2) - 5;
        let mob3YCode = (LR3 / 2) - 5;
        let mob3life = mob3_hp > 0;
        let mob4XCode = (UD4 / 2) - 5;
        let mob4YCode = (LR4 / 2) - 5;
        let mob4life = mob4_hp > 0;
        let mob5XCode = (UD5 / 2) - 5;
        let mob5YCode = (LR5 / 2) - 5;
        let mob5life = mob5_hp > 0;
        let mob6XCode = (UD6 / 2) - 5;
        let mob6YCode = (LR6 / 2) - 5;
        let mob6life = mob6_hp > 0;
        let floor = charac.floor;
        let room = charac.room;

        let rows = 40;
        let cols = 40;

        const map = new Array(rows).fill(null).map(() => new Array(cols).fill(0));

        // 캐릭터 위치 부여
        if (something !== 1) {
            for (let x = characXCode; x < characXCode + 5; x++) {
                for (let y = characYCode; y < characYCode + 5; y++) {
                    map[x][y] = 1;
                }
            }
        }

        // 몬스터 위치 부여
        if (room > 0 && room < 5 && mob2life && something !== 2) {
            for (let x = mob2XCode; x < mob2XCode + 5; x++) {
                for (let y = mob2YCode; y < mob2YCode + 5; y++) {
                    map[x][y] = 2;
                }
            }
        }
        if (room > 1 && room < 5 && mob3life && something !== 3) {
            for (let x = mob3XCode; x < mob3XCode + 5; x++) {
                for (let y = mob3YCode; y < mob3YCode + 5; y++) {
                    map[x][y] = 3;
                }
            }
        }
        if (room > 2 && room < 5 && mob4life && something !== 4) {
            for (let x = mob4XCode; x < mob4XCode + 5; x++) {
                for (let y = mob4YCode; y < mob4YCode + 5; y++) {
                    map[x][y] = 4;
                }
            }
        }
        if (room > 3 && room < 5 && mob5life && something !== 5) {
            for (let x = mob5XCode; x < mob5XCode + 5; x++) {
                for (let y = mob5YCode; y < mob5YCode + 5; y++) {
                    map[x][y] = 5;
                }
            }
        }
        if (floor > 1 && room === 0 && mob6life && something !== 6) {
            for (let x = mob6XCode; x < mob6XCode + 10; x++) {
                for (let y = mob6YCode; y < mob6YCode + 10; y++) {
                    map[x][y] = 6;
                }
            }
        }
        return map;
    }

    function somethingDistance(something, weaponId, floor) {
        if (something === 1) {
            if (weaponId % 10 === 1) {
                return 4;
            } else if (weaponId % 10 === 2) {
                return 5;
            } else if (weaponId % 10 === 3) {
                return 6;
            } else if (weaponId % 10 === 4) {
                return 7;
            } else if (weaponId % 10 === 5) {
                return 8;
            } else if (weaponId % 10 === 6) {
                return 9;
            } else if (weaponId % 10 === 7) {
                return 10;
            } else if (weaponId % 10 === 8) {
                return 11;
            } else if (weaponId % 10 === 9) {
                return 12;
            } else if (weaponId % 10 === 0) {
                return 13;
            }
        } else {
            if (floor <= 4) {
                return 3;
            } else if (floor <= 5) {
                return 4;
            } else if (floor <= 6) {
                return 5;
            } else if (floor <= 7) {
                return 6;
            } else if (floor <= 8) {
                return 7;
            } else if (floor <= 9) {
                return 8;
            } else if (floor <= 10) {
                return 9;
            } else if (floor <= 11) {
                return 10;
            } else if (floor <= 12) {
                return 11;
            } else {
                return 12;
            }
        }
        return 3;
    }

    // 공격 모션 실행 함수
    function attack_motion(something, motion) {
        let Distance = 0;

        // console.log(front_weaponId);

        if (something === 1) {
            Distance = front_weaponId % 10; // 소수점 아래 버림
            if (front_weaponId % 10 === 0) {
                Distance = 10;
            }
        } else {
            Distance = charac.floor - 3;
            if (Distance > 10) {
                Distance = 10;
            }
        }

        const $attackElement = $("." + motion + "attack" + something);

        // hidden 클래스를 제거해서 모습을 드러냄
        $attackElement.removeClass('hidden');

        // 약간의 딜레이 후에 css 를 변경해 이동하는 모습을 표현
        setTimeout(function () {
            if (motion === 'A') {
                $attackElement.css('left', (-4 - (Distance * 2)) + "vh");
            } else if (motion === 'W') {
                $attackElement.css('top', (-4 - (Distance * 2)) + "vh");
            } else if (motion === 'D') {
                if (something < 6) {
                    $attackElement.css('left', (12 + (Distance * 2)) + "vh");
                } else if (something === 6) {
                    $attackElement.css('left', (22 + (Distance * 2)) + "vh");
                }
            } else if (motion === 'S') {
                if (something < 6) {
                    $attackElement.css('top', (12 + (Distance * 2)) + "vh");
                } else if (something === 6) {
                    $attackElement.css('top', (22 + (Distance * 2)) + "vh");
                }
            }
        }, 10);  // 10ms 정도의 짧은 딜레이를 줘서 CSS 변경을 애니메이션으로 적용

        // 0.5초 뒤에 애니메이션이 끝나고, 모습을 없애고 원래 자리로
        setTimeout(function () {
            $attackElement.addClass('hidden'); // 다시 hidden 추가
            if (something < 6) {
                $attackElement.css({top: "4vh", left: "4vh"}); // 원래 위치로 복귀
            } else if (something === 6) {
                $attackElement.css({top: "9vh", left: "9vh"}); // 원래 위치로 복귀
            }
        }, 500);  // 애니메이션 시간 500ms 이후
    }

    var isConfirm = true; // 알림창 중복 방지 플래그

    // 스테이지 이동
    function stageUp(callback) {
        let doorChack = $(".door").hasClass("hidden");
        if ((callback || (LR > 79 && 38 < UD && UD < 52)) && !doorChack) {
            stopMoving();
            const isItemHidden = $item.hasClass('hidden');
            if (!isItemHidden && isConfirm && charac.floor <= 5) {
                console.log('2단계 진입' + isConfirm);
                // isConfirm이 true일 때만 confirm() 실행
                if (!confirm('무기를 획득하지 않았습니다. 그래도 이동하시겠습니까?')) {
                    console.log('3단계 진입' + isConfirm);
                    isConfirm = false; // 취소한 경우, 이동하지 않음
                    return;
                } else {
                    console.log('4단계 진입' + isConfirm);
                    stageSave(callback);
                }
            } else if (!isConfirm && charac.floor <= 5) {
                console.log('5단계 진입' + isConfirm);
                stageSave(callback);
            } else if (charac.floor > 5) {
                console.log('6단계 진입' + isConfirm);
                stageSave(callback);
            } else if (isItemHidden) {
                console.log('7단계 진입' + isConfirm);
                stageSave(callback);
            }
            stageSave(callback);
        } else {
            if (callback) callback(); // 조건이 안 맞아도 실행
        }
    }

    function stageSave(callback) {
        let floor = charac.floor;
        let room = charac.room;

        if (room + 1 < 5) {
            room++;
        } else {
            room = 0;
            floor++;
        }

        setTimeout(function () {
            const characData = {
                name: nickname,
                floor: floor,
                room: room,
                hp: front_hp,
                power: front_power,
                speed: front_speed,
                weaponId: front_weaponId,
                weaponUpgrade: front_weaponUpgrade,
                clearTime: seconds
            };

            if (characData.room !== 1) {
                localStorage.setItem(nickname, JSON.stringify(characData));
            } else if (front_hp + 10 > 100) {
                characData.hp = 100;
                localStorage.setItem(nickname, JSON.stringify(characData));
            } else if (characData.room === 1) {
                characData.hp = front_hp + 10;
                localStorage.setItem(nickname, JSON.stringify(characData));
            }

            // 로컬 저장 후 이동 (콜백 함수 실행)
            if (callback) callback();
            else location.reload();
        }, 100);
    }

    // 버튼 클릭 시 스테이지 업 후 페이지 이동
    $(".mob__list_bt").on("click", function () {
        stageUp(function () {
            location.href = '../dictionary/mob';
        });
    });

    $(".weapon__list_bt").on("click", function () {
        stageUp(function () {
            location.href = '../dictionary/weapon';
        });
    });

    // 데미지 화면에 보여주기
    function damage__motion(data, damage) {
        // console.log(data, damage)
        mobHpDown(data);
        $(".damage" + data).text(damage);
        setTimeout(function () {
            $(".damage" + data).text('');
        }, 1000);
    }

    // 몬스터 체력바 변화 함수
    function mobHpDown(something) {
        let mob_hp = 0;
        if (something === 2) {
            mob_hp = mob2_hp;
        } else if (something === 3) {
            mob_hp = mob3_hp;
        } else if (something === 4) {
            mob_hp = mob4_hp;
        } else if (something === 5) {
            mob_hp = mob5_hp;
        }
        let new_mobHp_width = (8 / (charac.floor * 10)) * mob_hp;
        if (mob_hp <= 0) new_mobHp_width = 0;
        $(".mob" + something + "HP_bar").css('width', new_mobHp_width + 'vh');
    }

    // 보스 체력바 변화 함수
    function BossHpDown() {
        let new_bossHp_width = (50 / ((charac.floor - 1) * 100) * mob6_hp);
        if (mob6_hp <= 0) new_bossHp_width = 0;
        $(".bossHP_bar").css('width', new_bossHp_width + 'vh');
    }

    // 몬스터 hp 셋팅
    var mob2_hp = 0;
    var mob3_hp = 0;
    var mob4_hp = 0;
    var mob5_hp = 0;
    var mob6_hp = 0;

    // 몬스터의 체력 부여
    if (charac.room > 0 && charac.room < 5) {
        $('.mob2').removeClass('hidden');
        mob2_hp = charac.floor * 10;
    }
    if (charac.room > 1 && charac.room < 5) {
        $('.mob3').removeClass('hidden');
        mob3_hp = charac.floor * 10;
    }
    if (charac.room > 2 && charac.room < 5) {
        $('.mob4').removeClass('hidden');
        mob4_hp = charac.floor * 10;
    }
    if (charac.room > 3 && charac.room < 5) {
        $('.mob5').removeClass('hidden');
        mob5_hp = charac.floor * 10;
    }
    if (charac.floor > 1 && charac.room === 0) {
        $('.mob6').removeClass('hidden');
        $('.bossHP').removeClass('hidden');
        mob6_hp = (charac.floor - 1) * 100;
    }

    // 자동 실행 move 함수 담아놓을 변수 생성
    var stop2, stop3, stop4, stop5, stop6;

    //일정 시간마다 move 함수를 호출
    function show() {
        console.log("페이지가 모두 로드된 후 실행됩니다.");
        // console.log(((8 / 100) * front_hp));

        setTimeout(characHpDown, 1000);
        setTimeout(() => mobHpDown(2), 1000);
        setTimeout(() => mobHpDown(3), 1000);
        setTimeout(() => mobHpDown(4), 1000);
        setTimeout(() => mobHpDown(5), 1000);
        $('body').css('cursor', 'none');

        if (charac.floor <= 10) {
            if (charac.room > 0 && charac.room < 5) {
                stop2 = setInterval(() => move(2), 1000);
            }
            if (charac.room > 1 && charac.room < 5) {
                stop3 = setInterval(() => move(3), 800);
            }
            if (charac.room > 2 && charac.room < 5) {
                stop4 = setInterval(() => move(4), 500);
            }
            if (charac.room > 3 && charac.room < 5) {
                stop5 = setInterval(() => move(5), 200);
            }
            if (charac.floor > 1 && charac.room === 0) {
                stop6 = setInterval(() => move(6), 200);
            }
        } else {
            if (charac.room > 0 && charac.room < 5) {
                stop2 = setInterval(() => move(2), 500);
            }
            if (charac.room > 1 && charac.room < 5) {
                stop3 = setInterval(() => move(3), 400);
            }
            if (charac.room > 2 && charac.room < 5) {
                stop4 = setInterval(() => move(4), 250);
            }
            if (charac.room > 3 && charac.room < 5) {
                stop5 = setInterval(() => move(5), 100);
            }
            if (charac.floor > 1 && charac.room === 0) {
                stop6 = setInterval(() => move(6), 100);
            }
        }
    }

    // 랜덤 행동을 사용하는 함수
    function move(something) {
        let random;
        // 1에서 5까지의 랜덤 숫자 생성
        if (charac.floor < 4) {
            random = getRandom(1, 4);
        } else {
            random = getRandom(1, 5);
        }

        // console.log('random : ' + random);
        // console.log('windowChack : ' + windowChack);
        // console.log('something : ' + something);

        if (random === 1) {
            moveCharacter('left', something)
        } else if (random === 2) {
            moveCharacter('up', something)
        } else if (random === 3) {
            moveCharacter('right', something)
        } else if (random === 4) {
            moveCharacter('down', something)
        } else if (random === 5) {
            mobAttack(something);
        }
    }


    // 몬스터의 공격
    function mobAttack(something) {
        let randomAttack = getRandom(1, 4);
        if (randomAttack === 1) {
            attack('A', something);
        } else if (randomAttack === 2) {
            attack('W', something);
        } else if (randomAttack === 3) {
            attack('D', something);
        } else if (randomAttack === 4) {
            attack('S', something);
        }
    }

    // 문 개방
    function showDoor() {
        if (mob2_hp <= 0 && mob3_hp <= 0 && mob4_hp <= 0 && mob5_hp <= 0 && mob6_hp <= 0) {
            $(".door").fadeIn(1000).removeClass('hidden');
        }
    }

    var timeoutId;

    // 마우스가 움직이면 호출되는 함수
    function resetCursorTimer() {
        // 커서를 다시 보이도록 설정
        $('body').css('cursor', 'default');

        // 이전 타이머가 있다면 취소
        clearTimeout(timeoutId);

        // 설정한 시간 후에 커서를 숨김
        timeoutId = setTimeout(function () {
            $('body').css('cursor', 'none');
        }, 1000);
    }

    // 페이지가 처음 로드될 때 타이머 시작
    timeoutId = setTimeout(function () {
        $('body').css('cursor', 'none');
    }, 3000);

    // 마우스가 움직일 때마다 타이머를 리셋
    $(document).on('mousemove', resetCursorTimer);

    show();
});

var mobFind = localStorage.getItem(nickname + 'MobFind') || 1;

if (charac.room === 1) {
    if (mobFind < charac.floor) {
        localStorage.setItem(nickname + 'MobFind', charac.floor);
        mobFind = charac.floor;
    }
}

if (mobFind > mobs.length - 1) mobFind = mobs.length - 1;

for (let i = 1; i <= mobFind; i++) {
    $('.mobImage' + i).attr('src', mobs[i])

    // 현재 순서에 해당하는 mob__dictionary_card2 선택
    const currentCard = $('.mob__dictionary_card2').eq(i - 1);

    // 카드 요소에 새로운 div 추가
    currentCard.append(`
        <div class="dictionary_body_text absolute">
            데미지 ${i} <br> 체력 ${i * 10} <br> 사거리 ${i < 4 ? 0 : i - 1 > 12 ? 12 : i - 1}
        </div>
    `);
}

/*for (i = 1; i <= 70; i++) {
    let weaponFind = localStorage.getItem(nickname + 'weaponFind' + i);
    if(weaponFind) $('.weaponImage' + i).attr('src', weapon[i])
}*/

$.each(Object.keys(localStorage), function (_, key) {
    if (key.startsWith(`${nickname}weaponFind`)) {
        const index = key.replace(`${nickname}weaponFind`, ''); // 숫자 추출
        const indexNumber = parseInt(index, 10);

        if (weapon[indexNumber]) {
            $(`.weaponImage${indexNumber}`).attr('src', weapon[indexNumber]);
        }

        // 현재 순서에 해당하는 weapon__dictionary_card2 선택
        const currentCard = $('.weapon__dictionary_card2').eq(indexNumber - 1);

        currentCard.append(`
        <div class="dictionary_body_text absolute">            
            데미지 ${Math.ceil(indexNumber / 10) * 10} <br>
            사거리 ${indexNumber % 10 === 0 ? 12 : (indexNumber % 10) + 2}
        </div>
        `);
    }
});

// 인게임 헤드 js
var mob__itemsPerPage = 4; // 몬스터 도감 한 페이지에 보여줄 카드 개수
var mob__currentIndex = 0; // 몬스터 도감 현재 첫 번째로 보여지는 카드의 인덱스
var mob__totalItems = $('.mob__dictionary_card').length; // 몬스터 도감 총 몬스터 수
var mob__cardWidth = 20; // 몬스터 도감 카드의 너비(마진 포함)

var weapon__itemsPerPage = 4; // 무기 도감 한 페이지에 보여줄 카드 개수
var weapon__currentIndex = 0; // 무기 도감 현재 첫 번째로 보여지는 카드의 인덱스
var weapon__totalItems = $('.weapon__dictionary_card').length; // 무기 도감 총 무기 수
var weapon__cardWidth = 20; // 무기 도감 카드의 너비(마진 포함)

function mob__updateSlide() {
    // 이동할 위치 계산 (현재 인덱스에 맞게 이동)
    let mob__translateX = -mob__currentIndex * (mob__cardWidth + 3.5);
    $('.mob__dictionary_inner').css('transform', 'translateX(' + mob__translateX + 'vh)');
}

function mob__next() {
    if (mob__currentIndex + mob__itemsPerPage < mob__totalItems) {
        mob__currentIndex++;
    } else {
        mob__currentIndex = 0; // 마지막 카드에 도달하면 처음으로 돌아가기
    }
    mob__updateSlide();
}

function mob__prev() {
    if (mob__currentIndex > 0) {
        mob__currentIndex--;
    } else {
        mob__currentIndex = mob__totalItems - mob__itemsPerPage; // 처음으로 돌아가면 마지막 페이지로 이동
    }
    mob__updateSlide();
}

function weapon__updateSlide() {
    // 이동할 위치 계산 (현재 인덱스에 맞게 이동)
    let weapon__translateX = -weapon__currentIndex * (weapon__cardWidth + 3.5);
    // console.log("weapon__currentIndex : " + weapon__currentIndex);
    // console.log("weapon__itemsPerPage : " + weapon__itemsPerPage);
    // console.log("weapon__totalItems : " + weapon__totalItems);
    // console.log("weapon__cardWidth : " + weapon__cardWidth);
    // console.log("weapon__translateX : " + weapon__translateX);
    $('.weapon__dictionary_inner').css('transform', 'translateX(' + weapon__translateX + 'vh)');
}

function weapon__next() {
    if (weapon__currentIndex + weapon__itemsPerPage < weapon__totalItems) {
        weapon__currentIndex++;
    } else {
        weapon__currentIndex = 0; // 마지막 카드에 도달하면 처음으로 돌아가기
    }
    weapon__updateSlide();
}

function weapon__prev() {
    if (weapon__currentIndex > 0) {
        weapon__currentIndex--;
    } else {
        weapon__currentIndex = weapon__totalItems - weapon__itemsPerPage; // 처음으로 돌아가면 마지막 페이지로 이동
    }
    weapon__updateSlide();
}

// 몬스터 도감 버튼 클릭했을때 적용되는 함수
function showMob__dictionary() {
    $('.mob__dictionary').toggleClass('hidden');
    $('.mob__prev_bt').toggleClass('hidden');
    $('.mob__list_bt').toggleClass('hidden');
    $('.mob__next_bt').toggleClass('hidden');
    const $mob__dictionary_bt = $('.mob__dictionary_bt');
    $mob__dictionary_bt.toggleClass('play');
    $mob__dictionary_bt.toggleClass('pause');
}

function showWeapon__dictionary() {
    $('.weapon__dictionary').toggleClass('hidden');
    $('.weapon__prev_bt').toggleClass('hidden');
    $('.weapon__list_bt').toggleClass('hidden');
    $('.weapon__next_bt').toggleClass('hidden');
    const $weapon__dictionary_bt = $('.weapon__dictionary_bt');
    $weapon__dictionary_bt.toggleClass('play');
    $weapon__dictionary_bt.toggleClass('pause');
}

const bgTrackCount = 4;
const $audioPlayer = $('#audioPlayer');
const storageKey = 'audioPlaybackData';

function calculateBgTrackNumber(floor, room) {
    // console.log(floor + ',' + room);
    const roomOffset = (floor % 10 === 0 && room === 0) ? 0 : 1;
    return Math.floor((floor / 10) % bgTrackCount) + roomOffset;
}

let previousFloor = charac.floor;
let previousRoom = charac.room;

// 이전 오디오 트랙 계산
let previousTrackNumber = calculateBgTrackNumber(previousFloor - (previousRoom === 0 ? 1 : 0), previousRoom === 0 ? 4 : previousRoom - 1);
let currentTrackNumber = calculateBgTrackNumber(charac.floor, charac.room);

function bgChange() {
    // console.log('previousTrackNumber : ' + previousTrackNumber);
    // console.log('currentTrackNumber : ' + currentTrackNumber);
    if (previousTrackNumber !== currentTrackNumber) {
        const bgAudioData = {
            currentTime: 0, // 타임을 0초로 리셋
            isPlaying: $audioPlayer[0].paused // 현재 재생 중인지 여부를 그대로 유지
        };
        localStorage.setItem(storageKey, JSON.stringify(bgAudioData));
    }
}

bgChange();

$(window).on('beforeunload', function () {
    const unloadAudioData = {
        currentTime: $audioPlayer[0].currentTime,
        isPlaying: !$audioPlayer[0].paused
    };
    localStorage.setItem(storageKey, JSON.stringify(unloadAudioData));
});

$(document).ready(function () {
    const $toggleButton = $('#toggleAutoplayButton');

    // 오디오 파일 로드 및 준비
    $audioPlayer[0].pause();
    $audioPlayer.attr('src', `../audio/bg${currentTrackNumber}.mp3`);
    $audioPlayer[0].load();

    // 로컬 저장된 데이터가 있으면 그 상태로 복원
    const savedData = JSON.parse(localStorage.getItem(storageKey));
    if (savedData) {
        $audioPlayer[0].currentTime = savedData.currentTime;
        if (savedData.isPlaying) {
            $audioPlayer[0].play();
            $toggleButton.removeClass('play').addClass('pause');
        } else {
            $audioPlayer[0].pause();
            $toggleButton.removeClass('pause').addClass('play');
        }
    }

    // 첫 번째 클릭 시 오디오 재생
    $toggleButton.on('click', function () {
        if ($audioPlayer[0].paused) {
            $audioPlayer[0].play().then(() => {
                localStorage.setItem(storageKey, JSON.stringify({
                    currentTime: $audioPlayer[0].currentTime,
                    isPlaying: true
                }));
                $(this).removeClass('play').addClass('pause');
            }).catch((error) => {
                console.error("오디오 재생 실패:", error);
            });
        } else {
            $audioPlayer[0].pause();
            localStorage.setItem(storageKey, JSON.stringify({
                currentTime: $audioPlayer[0].currentTime,
                isPlaying: false
            }));
            $(this).removeClass('pause').addClass('play');
        }
    });
});
